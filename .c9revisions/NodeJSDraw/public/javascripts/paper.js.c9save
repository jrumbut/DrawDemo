{"ts":1356756096631,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1356756099135,"patch":[[{"diffs":[[1,"/*!\n * Paper.js v0.22\n *\n * This file is part of Paper.js, a JavaScript Vector Graphics Library,\n * based on Scriptographer.org and designed to be largely API compatible.\n * http://paperjs.org/\n * http://scriptographer.org/\n *\n * Copyright (c) 2011, Juerg Lehni & Jonathan Puckey\n * http://lehni.org/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Thu Nov 10 19:19:25 2011 +0100\n *\n ***\n *\n * Bootstrap.js JavaScript Framework.\n * http://bootstrapjs.org/\n *\n * Copyright (c) 2006 - 2011 Juerg Lehni\n * http://lehni.org/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Parse-js\n *\n * A JavaScript tokenizer / parser / generator, originally written in Lisp.\n * Copyright (c) Marijn Haverbeke <marijnh@gmail.com>\n * http://marijn.haverbeke.nl/parse-js/\n *\n * Ported by to JavaScript by Mihai Bazon\n * Copyright (c) 2010, Mihai Bazon <mihai.bazon@gmail.com>\n * http://mihai.bazon.net/blog/\n *\n * Modifications and adaptions to browser (c) 2011, Juerg Lehni\n * http://lehni.org/\n *\n * Distributed under the BSD license.\n */\n\nvar paper = new function() {\n\nvar Base = new function() { \n    var fix = !this.__proto__,\n\t\thidden = /^(statics|generics|preserve|enumerable|prototype|__proto__|toString|valueOf)$/,\n\t\tproto = Object.prototype,\n\t\thas = fix\n\t\t\t? function(name) {\n\t\t\t\treturn name !== '__proto__' && this.hasOwnProperty(name);\n\t\t\t}\n\t\t\t: proto.hasOwnProperty,\n\t\ttoString = proto.toString,\n\t\tproto = Array.prototype,\n\t\tisArray = Array.isArray = Array.isArray || function(obj) {\n\t\t\treturn toString.call(obj) === '[object Array]';\n\t\t},\n\t\tslice = proto.slice,\n\t\tforEach = proto.forEach = proto.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++)\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t},\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this)\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t},\n\t\t_define = Object.defineProperty,\n\t\t_describe = Object.getOwnPropertyDescriptor;\n\n\tfunction define(obj, name, desc) {\n\t\tif (_define) {\n\t\t\ttry {\n\t\t\t\tdelete obj[name];\n\t\t\t\treturn _define(obj, name, desc);\n\t\t\t} catch (e) {}\n\t\t}\n\t\tif ((desc.get || desc.set) && obj.__defineGetter__) {\n\t\t\tdesc.get && obj.__defineGetter__(name, desc.get);\n\t\t\tdesc.set && obj.__defineSetter__(name, desc.set);\n\t\t} else {\n\t\t\tobj[name] = desc.value;\n\t\t}\n\t\treturn obj;\n\t}\n\n\tfunction describe(obj, name) {\n\t\tif (_describe) {\n\t\t\ttry {\n\t\t\t\treturn _describe(obj, name);\n\t\t\t} catch (e) {}\n\t\t}\n\t\tvar get = obj.__lookupGetter__ && obj.__lookupGetter__(name);\n\t\treturn get\n\t\t\t? { get: get, set: obj.__lookupSetter__(name), enumerable: true,\n\t\t\t\t\tconfigurable: true }\n\t\t\t: has.call(obj, name)\n\t\t\t\t? { value: obj[name], enumerable: true, configurable: true,\n\t\t\t\t\t\twritable: true }\n\t\t\t\t: null;\n\t}\n\n\tfunction inject(dest, src, enumerable, base, preserve, generics) {\n\t\tvar beans, bean;\n\n\t\tfunction field(name, val, dontCheck, generics) {\n\t\t\tvar val = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value),\n\t\t\t\tfunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || func\n\t\t\t\t\t? (val && val.get ? name in dest : dest[name]) : null;\n\t\t\tif (generics && func && (!preserve || !generics[name])) {\n\t\t\t\tgenerics[name] = function(bind) {\n\t\t\t\t\treturn bind && dest[name].apply(bind,\n\t\t\t\t\t\t\tslice.call(arguments, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((dontCheck || val !== undefined && has.call(src, name))\n\t\t\t\t\t&& (!preserve || !prev)) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (prev && /\\bthis\\.base\\b/.test(val)) {\n\t\t\t\t\t\tvar fromBase = base && base[name] == prev;\n\t\t\t\t\t\tres = function() {\n\t\t\t\t\t\t\tvar tmp = describe(this, 'base');\n\t\t\t\t\t\t\tdefine(this, 'base', { value: fromBase\n\t\t\t\t\t\t\t\t? base[name] : prev, configurable: true });\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn val.apply(this, arguments);\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\ttmp ? define(this, 'base', tmp)\n\t\t\t\t\t\t\t\t\t: delete this.base;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tres.toString = function() {\n\t\t\t\t\t\t\treturn val.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres.valueOf = function() {\n\t\t\t\t\t\t\treturn val.valueOf();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (beans && val.length == 0\n\t\t\t\t\t\t\t&& (bean = name.match(/^(get|is)(([A-Z])(.*))$/)))\n\t\t\t\t\t\tbeans.push([ bean[3].toLowerCase() + bean[4], bean[2] ]);\n\t\t\t\t}\n\t\t\t\tif (!res || func || !res.get && !res.set)\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tbeans = [];\n\t\t\tfor (var name in src)\n\t\t\t\tif (has.call(src, name) && !hidden.test(name))\n\t\t\t\t\tfield(name, null, true, generics);\n\t\t\tfield('toString');\n\t\t\tfield('valueOf');\n\t\t\tfor (var i = 0, l = beans && beans.length; i < l; i++)\n\t\t\t\ttry {\n\t\t\t\t\tvar bean = beans[i], part = bean[1];\n\t\t\t\t\tfield(bean[0], {\n\t\t\t\t\t\tget: dest['get' + part] || dest['is' + part],\n\t\t\t\t\t\tset: dest['set' + part]\n\t\t\t\t\t}, true);\n\t\t\t\t} catch (e) {}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction extend(obj) {\n\t\tvar ctor = function(dont) {\n\t\t\tif (fix) define(this, '__proto__', { value: obj });\n\t\t\tif (this.initialize && dont !== ctor.dont)\n\t\t\t\treturn this.initialize.apply(this, arguments);\n\t\t}\n\t\tctor.prototype = obj;\n\t\tctor.toString = function() {\n\t\t\treturn (this.prototype.initialize || function() {}).toString();\n\t\t}\n\t\treturn ctor;\n\t}\n\n\tfunction iterator(iter) {\n\t\treturn !iter\n\t\t\t? function(val) { return val }\n\t\t\t: typeof iter !== 'function'\n\t\t\t\t? function(val) { return val == iter }\n\t\t\t\t: iter;\n\t}\n\n\tfunction each(obj, iter, bind, asArray) {\n\t\ttry {\n\t\t\tif (obj)\n\t\t\t\t(asArray || asArray === undefined && isArray(obj)\n\t\t\t\t\t? forEach : forIn).call(obj, iterator(iter),\n\t\t\t\t\t\tbind = bind || obj);\n\t\t} catch (e) {\n\t\t\tif (e !== Base.stop) throw e;\n\t\t}\n\t\treturn bind;\n\t}\n\n\tfunction clone(obj) {\n\t\treturn each(obj, function(val, i) {\n\t\t\tthis[i] = val;\n\t\t}, new obj.constructor());\n\t}\n\n\treturn inject(function() {}, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar proto = this.prototype,\n\t\t\t\t\tbase = proto.__proto__ && proto.__proto__.constructor,\n\t\t\t\t\tstatics = src.statics == true ? src : src.statics;\n\t\t\t\tif (statics != src)\n\t\t\t\t\tinject(proto, src, src.enumerable, base && base.prototype,\n\t\t\t\t\t\t\tsrc.preserve, src.generics && this);\n\t\t\t\tinject(this, statics, true, base, src.preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function(src) {\n\t\t\tvar proto = new this(this.dont),\n\t\t\t\tctor = extend(proto);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tctor.dont = {};\n\t\t\tinject(ctor, this, true);\n\t\t\treturn arguments.length ? this.inject.apply(ctor, arguments) : ctor;\n\t\t}\n\t}, true).inject({\n\t\thas: has,\n\t\teach: each,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++)\n\t\t\t\tinject(this, arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = new (extend(this));\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn clone(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\teach: each,\n\t\t\tclone: clone,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\t\t\titerator: iterator,\n\n\t\t\thas: function(obj, name) {\n\t\t\t\treturn has.call(obj, name);\n\t\t\t},\n\n\t\t\ttype: function(obj) {\n\t\t\t\treturn (obj || obj === 0) && (obj._type || typeof obj) || null;\n\t\t\t},\n\n\t\t\tcheck: function(obj) {\n\t\t\t\treturn !!(obj || obj === 0);\n\t\t\t},\n\n\t\t\tpick: function() {\n\t\t\t\tfor (var i = 0, l = arguments.length; i < l; i++)\n\t\t\t\t\tif (arguments[i] !== undefined)\n\t\t\t\t\t\treturn arguments[i];\n\t\t\t\treturn null;\n\t\t\t},\n\n\t\t\tstop: {}\n\t\t}\n\t});\n}\n\nthis.Base = Base.inject({\n\tgenerics: true,\n\n\tclone: function() {\n\t\treturn new this.constructor(this);\n\t},\n\n\ttoString: function() {\n\t\treturn '{ ' + Base.each(this, function(value, key) {\n\t\t\tif (key.charAt(0) != '_') {\n\t\t\t\tvar type = typeof value;\n\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t? Base.formatNumber(value)\n\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t}\n\t\t}, []).join(', ') + ' }';\n\t},\n\n\tstatics: {\n\t\tread: function(list, start, length) {\n\t\t\tvar start = start || 0,\n\t\t\t\tlength = length || list.length - start;\n\t\t\tvar obj = list[start];\n\t\t\tif (obj instanceof this\n\t\t\t\t\t|| this.prototype._readNull && obj == null && length <= 1)\n\t\t\t\treturn obj;\n\t\t\tobj = new this(this.dont);\n\t\t\treturn obj.initialize.apply(obj, start > 0 || length < list.length\n\t\t\t\t? Array.prototype.slice.call(list, start, start + length)\n\t\t\t\t: list) || obj;\n\t\t},\n\n\t\treadAll: function(list, start) {\n\t\t\tvar res = [], entry;\n\t\t\tfor (var i = start || 0, l = list.length; i < l; i++) {\n\t\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0)\n\t\t\t\t\t: this.read(list, i, 1));\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\n\t\tsplice: function(list, items, index, remove) {\n\t\t\tvar amount = items && items.length,\n\t\t\t\tappend = index === undefined;\n\t\t\tindex = append ? list.length : index;\n\t\t\tfor (var i = 0; i < amount; i++)\n\t\t\t\titems[i]._index = index + i;\n\t\t\tif (append) {\n\t\t\t\tlist.push.apply(list, items);\n\t\t\t\treturn [];\n\t\t\t} else {\n\t\t\t\tvar args = [index, remove];\n\t\t\t\tif (items)\n\t\t\t\t\targs.push.apply(args, items);\n\t\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\t\tdelete removed[i]._index;\n\t\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\t\tlist[i]._index = i;\n\t\t\t\treturn removed;\n\t\t\t}\n\t\t},\n\n\t\tmerge: function() {\n\t\t\treturn Base.each(arguments, function(hash) {\n\t\t\t\tBase.each(hash, function(value, key) {\n\t\t\t\t\tthis[key] = value;\n\t\t\t\t}, this);\n\t\t\t}, new Base(), true); \n\t\t},\n\n\t\tcapitalize: function(str) {\n\t\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\t\treturn match.toUpperCase();\n\t\t\t});\n\t\t},\n\n\t\tcamelize: function(str) {\n\t\t\treturn str.replace(/-(\\w)/g, function(all, chr) {\n\t\t\t\treturn chr.toUpperCase();\n\t\t\t});\n\t\t},\n\n\t\thyphenate: function(str) {\n\t\t\treturn str.replace(/[a-z][A-Z0-9]|[0-9][a-zA-Z]|[A-Z]{2}[a-z]/g,\n\t\t\t\tfunction(match) {\n\t\t\t\t\treturn match.charAt(0) + '-' + match.substring(1);\n\t\t\t\t}\n\t\t\t).toLowerCase();\n\t\t},\n\n\t\tformatNumber: function(num) {\n\t\t\treturn (Math.round(num * 100000) / 100000).toString();\n\t\t}\n\t}\n});\n\nvar PaperScope = this.PaperScope = Base.extend({\n\n\tinitialize: function(script) {\n\t\tpaper = this;\n\t\tthis.view = null;\n\t\tthis.views = [];\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tool = null;\n\t\tthis.tools = [];\n\t\tthis._id = script && (script.getAttribute('id') || script.src)\n\t\t\t\t|| ('paperscope-' + (PaperScope._id++));\n\t\tif (script)\n\t\t\tscript.setAttribute('id', this._id);\n\t\tPaperScope._scopes[this._id] = this;\n\t},\n\n\tversion: 0.22,\n\n\tevaluate: function(code) {\n\t\tvar res = PaperScript.evaluate(code, this);\n\t\tView.updateFocus();\n\t\treturn res;\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this) {\n\t\t\tif (!/^(version|_id|load)/.test(key) && !(key in scope))\n\t\t\t\tscope[key] = this[key];\n\t\t}\n\t},\n\n\tsetup: function(canvas) {\n\t\tpaper = this;\n\t\tthis.project = new Project();\n\t\tif (canvas)\n\t\t\tthis.view = new View(canvas);\n\t},\n\n\tclear: function() {\n\t\tfor (var i = this.projects.length - 1; i >= 0; i--)\n\t\t\tthis.projects[i].remove();\n\t\tfor (var i = this.views.length - 1; i >= 0; i--)\n\t\t\tthis.views[i].remove();\n\t\tfor (var i = this.tools.length - 1; i >= 0; i--)\n\t\t\tthis.tools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\t_needsRedraw: function() {\n\t\tif (!this._redrawNotified) {\n\t\t\tfor (var i = this.views.length - 1; i >= 0; i--)\n\t\t\t\tthis.views[i]._redrawNeeded = true;\n\t\t\tthis._redrawNotified = true;\n\t\t}\n\t},\n\n\tstatics: {\n\t\t_scopes: {},\n\t\t_id: 0,\n\n\t\tget: function(id) {\n\t\t\tif (typeof id === 'object')\n\t\t\t\tid = id.getAttribute('id');\n\t\t\treturn this._scopes[id] || null;\n\t\t},\n\n\t\teach: function(iter) {\n\t\t\tBase.each(this._scopes, iter);\n\t\t}\n\t}\n});\n\nvar PaperScopeItem = Base.extend({\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tthis._scope[this._reference] = this;\n\t\treturn true;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t}\n});\n\nvar Point = this.Point = Base.extend({\n\tinitialize: function(arg0, arg1) {\n\t\tif (arg1 !== undefined) {\n\t\t\tthis.x = arg0;\n\t\t\tthis.y = arg1;\n\t\t} else if (arg0 !== undefined) {\n\t\t\tif (arg0 == null) {\n\t\t\t\tthis.x = this.y = 0;\n\t\t\t} else if (arg0.x !== undefined) {\n\t\t\t\tthis.x = arg0.x;\n\t\t\t\tthis.y = arg0.y;\n\t\t\t} else if (arg0.width !== undefined) {\n\t\t\t\tthis.x = arg0.width;\n\t\t\t\tthis.y = arg0.height;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tthis.x = arg0[0];\n\t\t\t\tthis.y = arg0.length > 1 ? arg0[1] : arg0[0];\n\t\t\t} else if (arg0.angle !== undefined) {\n\t\t\t\tthis.x = arg0.length;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.setAngle(arg0.angle);\n\t\t\t} else if (typeof arg0 === 'number') {\n\t\t\t\tthis.x = this.y = arg0;\n\t\t\t} else {\n\t\t\t\tthis.x = this.y = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.x = this.y = 0;\n\t\t}\n\t},\n\n\tset: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn Point.create(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar format = Base.formatNumber;\n\t\treturn '{ x: ' + format(this.x) + ', y: ' + format(this.y) + ' }';\n\t},\n\n\tadd: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn Point.create(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn Point.create(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn Point.create(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn Point.create(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn Point.create(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn Point.create(-this.x, -this.y);\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tgetDistance: function(point, squared) {\n\t\tpoint = Point.read(arguments);\n\t\tvar x = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y;\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tgetLength: function() {\n\t\tvar l = this.x * this.x + this.y * this.y;\n\t\treturn arguments[0] ? l : Math.sqrt(l);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis.set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (scale == 0)\n\t\t\t\tthis.getAngle();\n\t\t\tthis.set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current != 0 ? length / current : 0,\n\t\t\tpoint = Point.create(this.x * scale, this.y * scale);\n\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians(arguments[0]) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tangle = this._angle = angle * Math.PI / 180;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis.set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetAngleInRadians: function() {\n\t\tif (arguments[0] === undefined) {\n\t\t\tif (this._angle == null)\n\t\t\t\tthis._angle = Math.atan2(this.y, this.x);\n\t\t\treturn this._angle;\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (div == 0) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\treturn Math.acos(this.dot(point) / div);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetAngleInDegrees: function() {\n\t\treturn this.getAngle(arguments[0]);\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t},\n\n\tgetDirectedAngle: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\trotate: function(angle, center) {\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\ts = Math.sin(angle),\n\t\t\tc = Math.cos(angle);\n\t\tpoint = Point.create(\n\t\t\tpoint.x * c - point.y * s,\n\t\t\tpoint.y * c + point.x * s\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\tequals: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn this.x == point.x && this.y == point.y;\n\t},\n\n\tisInside: function(rect) {\n\t\treturn rect.contains(this);\n\t},\n\n\tisClose: function(point, tolerance) {\n\t\treturn this.getDistance(point) < tolerance;\n\t},\n\n\tisColinear: function(point) {\n\t\treturn this.cross(point) < Numerical.TOLERANCE;\n\t},\n\n\tisOrthogonal: function(point) {\n\t\treturn this.dot(point) < Numerical.TOLERANCE;\n\t},\n\n\tisZero: function() {\n\t\treturn this.x == 0 && this.y == 0;\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tdot: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tif (point.isZero()) {\n\t\t\treturn Point.create(0, 0);\n\t\t} else {\n\t\t\tvar scale = this.dot(point) / point.dot(point);\n\t\t\treturn Point.create(\n\t\t\t\tpoint.x * scale,\n\t\t\t\tpoint.y * scale\n\t\t\t);\n\t\t}\n\t},\n\n\tstatics: {\n\t\tcreate: function(x, y) {\n\t\t\tvar point = new Point(Point.dont);\n\t\t\tpoint.x = x;\n\t\t\tpoint.y = y;\n\t\t\treturn point;\n\t\t},\n\n\t\tmin: function(point1, point2) {\n\t\t\tpoint1 = Point.read(arguments, 0, 1);\n\t\t\tpoint2 = Point.read(arguments, 1, 1);\n\t\t\treturn Point.create(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function(point1, point2) {\n\t\t\tpoint1 = Point.read(arguments, 0, 1);\n\t\t\tpoint2 = Point.read(arguments, 1, 1);\n\t\t\treturn Point.create(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn Point.create(Math.random(), Math.random());\n\t\t}\n\t}\n}, new function() { \n\n\treturn Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\n\t\tvar op = Math[name];\n\t\tthis[name] = function() {\n\t\t\treturn Point.create(op(this.x), op(this.y));\n\t\t};\n\t}, {});\n});\n\nvar LinkedPoint = Point.extend({\n\tset: function(x, y, dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tstatics: {\n\t\tcreate: function(owner, setter, x, y, dontLink) {\n\t\t\tif (dontLink)\n\t\t\t\treturn Point.create(x, y);\n\t\t\tvar point = new LinkedPoint(LinkedPoint.dont);\n\t\t\tpoint._x = x;\n\t\t\tpoint._y = y;\n\t\t\tpoint._owner = owner;\n\t\t\tpoint._setter = setter;\n\t\t\treturn point;\n\t\t}\n\t}\n});\n\nvar Size = this.Size = Base.extend({\n\tinitialize: function(arg0, arg1) {\n\t\tif (arg1 !== undefined) {\n\t\t\tthis.width = arg0;\n\t\t\tthis.height = arg1;\n\t\t} else if (arg0 !== undefined) {\n\t\t\tif (arg0 == null) {\n\t\t\t\tthis.width = this.height = 0;\n\t\t\t} else if (arg0.width !== undefined) {\n\t\t\t\tthis.width = arg0.width;\n\t\t\t\tthis.height = arg0.height;\n\t\t\t} else if (arg0.x !== undefined) {\n\t\t\t\tthis.width = arg0.x;\n\t\t\t\tthis.height = arg0.y;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tthis.width = arg0[0];\n\t\t\t\tthis.height = arg0.length > 1 ? arg0[1] : arg0[0];\n\t\t\t} else if (typeof arg0 === 'number') {\n\t\t\t\tthis.width = this.height = arg0;\n\t\t\t} else {\n\t\t\t\tthis.width = this.height = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.width = this.height = 0;\n\t\t}\n\t},\n\n\ttoString: function() {\n\t\tvar format = Base.formatNumber;\n\t\treturn '{ width: ' + format(this.width)\n\t\t\t\t+ ', height: ' + format(this.height) + ' }';\n\t},\n\n\tset: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn Size.create(this.width, this.height);\n\t},\n\n\tadd: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn Size.create(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn Size.create(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn Size.create(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn Size.create(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn Size.create(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn Size.create(-this.width, -this.height);\n\t},\n\n\tequals: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn this.width == size.width && this.height == size.height;\n\t},\n\n\tisZero: function() {\n\t\treturn this.width == 0 && this.height == 0;\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tcreate: function(width, height) {\n\t\t\treturn new Size(Size.dont).set(width, height);\n\t\t},\n\n\t\tmin: function(size1, size2) {\n\t\t\treturn Size.create(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn Size.create(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn Size.create(Math.random(), Math.random());\n\t\t}\n\t}\n}, new function() { \n\n\treturn Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\n\t\tvar op = Math[name];\n\t\tthis[name] = function() {\n\t\t\treturn Size.create(op(this.width), op(this.height));\n\t\t};\n\t}, {});\n});\n\nvar LinkedSize = Size.extend({\n\tset: function(width, height, dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tstatics: {\n\t\tcreate: function(owner, setter, width, height, dontLink) {\n\t\t\tif (dontLink)\n\t\t\t\treturn Size.create(width, height);\n\t\t\tvar size = new LinkedSize(LinkedSize.dont);\n\t\t\tsize._width = width;\n\t\t\tsize._height = height;\n\t\t\tsize._owner = owner;\n\t\t\tsize._setter = setter;\n\t\t\treturn size;\n\t\t}\n\t}\n});\n\nvar Rectangle = this.Rectangle = Base.extend({\n\tinitialize: function(arg0, arg1, arg2, arg3) {\n\t\tif (arguments.length == 4) {\n\t\t\tthis.x = arg0;\n\t\t\tthis.y = arg1;\n\t\t\tthis.width = arg2;\n\t\t\tthis.height = arg3;\n\t\t} else if (arguments.length == 2) {\n\t\t\tif (arg1 && arg1.x !== undefined) {\n\t\t\t\tvar point1 = Point.read(arguments, 0, 1);\n\t\t\t\tvar point2 = Point.read(arguments, 1, 1);\n\t\t\t\tthis.x = point1.x;\n\t\t\t\tthis.y = point1.y;\n\t\t\t\tthis.width = point2.x - point1.x;\n\t\t\t\tthis.height = point2.y - point1.y;\n\t\t\t\tif (this.width < 0) {\n\t\t\t\t\tthis.x = point2.x;\n\t\t\t\t\tthis.width = -this.width;\n\t\t\t\t}\n\t\t\t\tif (this.height < 0) {\n\t\t\t\t\tthis.y = point2.y;\n\t\t\t\t\tthis.height = -this.height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar point = Point.read(arguments, 0, 1);\n\t\t\t\tvar size = Size.read(arguments, 1, 1);\n\t\t\t\tthis.x = point.x;\n\t\t\t\tthis.y = point.y;\n\t\t\t\tthis.width = size.width;\n\t\t\t\tthis.height = size.height;\n\t\t\t}\n\t\t} else if (arg0) {\n\t\t\tthis.x = arg0.x || 0;\n\t\t\tthis.y = arg0.y || 0;\n\t\t\tthis.width = arg0.width || 0;\n\t\t\tthis.height = arg0.height || 0;\n\t\t} else {\n\t\t\tthis.x = this.y = this.width = this.height = 0;\n\t\t}\n\t},\n\n\tset: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tgetPoint: function() {\n\t\treturn LinkedPoint.create(this, 'setPoint', this.x, this.y,\n\t\t\t\targuments[0]);\n\t},\n\n\tsetPoint: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t\treturn this;\n\t},\n\n\tgetSize: function() {\n\t\treturn LinkedSize.create(this, 'setSize', this.width, this.height,\n\t\t\t\targuments[0]);\n\t},\n\n\tsetSize: function(size) {\n\t\tsize = Size.read(arguments);\n\t\tthis.width = size.width;\n\t\tthis.height = size.height;\n\t\treturn this;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tthis.width -= left - this.x;\n\t\tthis.x = left;\n\t\treturn this;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tthis.height -= top - this.y;\n\t\tthis.y = top;\n\t\treturn this;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tthis.width = right - this.x;\n\t\treturn this;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tthis.height = bottom - this.y;\n\t\treturn this;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width * 0.5;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tthis.x = x - this.width * 0.5;\n\t\treturn this;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height * 0.5;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tthis.y = y - this.height * 0.5;\n\t\treturn this;\n\t},\n\n\tgetCenter: function() {\n\t\treturn LinkedPoint.create(this, 'setCenter',\n\t\t\t\tthis.getCenterX(), this.getCenterY(), arguments[0]);\n\t},\n\n\tsetCenter: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\treturn this.setCenterX(point.x).setCenterY(point.y);\n\t},\n\n\tequals: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\treturn this.x == rect.x && this.y == rect.y\n\t\t\t\t&& this.width == rect.width && this.height == rect.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width == 0 || this.height == 0;\n\t},\n\n\ttoString: function() {\n\t\tvar format = Base.formatNumber;\n\t\treturn '{ x: ' + format(this.x)\n\t\t\t\t+ ', y: ' + format(this.y)\n\t\t\t\t+ ', width: ' + format(this.width)\n\t\t\t\t+ ', height: ' + format(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length == 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\treturn rect.x + rect.width > this.x\n\t\t\t\t&& rect.y + rect.height > this.y\n\t\t\t\t&& rect.x < this.x + this.width\n\t\t\t\t&& rect.y < this.y + this.height;\n\t},\n\n\tintersect: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\tvar x1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn Rectangle.create(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\tvar x1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn Rectangle.create(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn Rectangle.create(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function(hor, ver) {\n\t\tif (ver === undefined)\n\t\t\tver = hor;\n\t\treturn Rectangle.create(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t},\n\n\tstatics: {\n\t\tcreate: function(x, y, width, height) {\n\t\t\treturn new Rectangle(Rectangle.dont).set(x, y, width, height);\n\t\t}\n\t}\n}, new function() {\n\treturn Base.each([\n\t\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t\t],\n\t\tfunction(parts, index) {\n\t\t\tvar part = parts.join('');\n\t\t\tvar xFirst = /^[RL]/.test(part);\n\t\t\tif (index >= 4)\n\t\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\t\tgetX = 'get' + x,\n\t\t\t\tgetY = 'get' + y,\n\t\t\t\tsetX = 'set' + x,\n\t\t\t\tsetY = 'set' + y,\n\t\t\t\tget = 'get' + part,\n\t\t\t\tset = 'set' + part;\n\t\t\tthis[get] = function() {\n\t\t\t\treturn LinkedPoint.create(this, set,\n\t\t\t\t\t\tthis[getX](), this[getY](), arguments[0]);\n\t\t\t};\n\t\t\tthis[set] = function(point) {\n\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\treturn this[setX](point.x)[setY](point.y);\n\t\t\t};\n\t\t}, {});\n});\n\nvar LinkedRectangle = Rectangle.extend({\n\tset: function(x, y, width, height, dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tstatics: {\n\t\tcreate: function(owner, setter, x, y, width, height) {\n\t\t\tvar rect = new LinkedRectangle(LinkedRectangle.dont).set(\n\t\t\t\t\tx, y, width, height, true);\n\t\t\trect._owner = owner;\n\t\t\trect._setter = setter;\n\t\t\treturn rect;\n\t\t}\n\t}\n}, new function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key);\n\t\tvar internal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function(value) {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tdelete this._dontNotify;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}, {})\n\t);\n});\n\nvar Matrix = this.Matrix = Base.extend({\n\tinitialize: function(arg) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count == 6) {\n\t\t\tthis.set.apply(this, arguments);\n\t\t} else if (count == 1) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis.set.apply(this, arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (count == 0) {\n\t\t\tthis._a = this._d = 1;\n\t\t\tthis._c = this._b = this._tx = this._ty = 0;\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok)\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t},\n\n\tclone: function() {\n\t\treturn Matrix.create(this._a, this._c, this._b, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tset: function(a, c, b, d, tx, ty) {\n\t\tthis._a = a;\n\t\tthis._c = c;\n\t\tthis._b = b;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\treturn this;\n\t},\n\n\tscale: function( hor, ver, center) {\n\t\tif (arguments.length < 2 || typeof ver === 'object') {\n\t\t\tcenter = Point.read(arguments, 1);\n\t\t\tver = hor;\n\t\t} else {\n\t\t\tcenter = Point.read(arguments, 2);\n\t\t}\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= hor;\n\t\tthis._c *= hor;\n\t\tthis._b *= ver;\n\t\tthis._d *= ver;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\treturn this;\n\t},\n\n\ttranslate: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tvar x = point.x, y = point.y;\n\t\tthis._tx += x * this._a + y * this._b;\n\t\tthis._ty += x * this._c + y * this._d;\n\t\treturn this;\n\t},\n\n\trotate: function(angle, center) {\n\t\treturn this.concatenate(\n\t\t\t\tMatrix.getRotateInstance.apply(Matrix, arguments));\n\t},\n\n\tshear: function( hor, ver, center) {\n\t\tif (arguments.length < 2 || typeof ver === 'object') {\n\t\t\tcenter = Point.read(arguments, 1);\n\t\t\tver = hor;\n\t\t} else {\n\t\t\tcenter = Point.read(arguments, 2);\n\t\t}\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tc = this._c;\n\t\tthis._a += ver * this._b;\n\t\tthis._c += ver * this._d;\n\t\tthis._b += hor * a;\n\t\tthis._d += hor * c;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\treturn this;\n\t},\n\n\ttoString: function() {\n\t\tvar format = Base.formatNumber;\n\t\treturn '[[' + [format(this._a), format(this._b),\n\t\t\t\t\tformat(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [format(this._c), format(this._d),\n\t\t\t\t\tformat(this._ty)].join(', ') + ']]';\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._c, this._b, this._d, this._tx, this._ty ];\n\t},\n\n\tconcatenate: function(mx) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = mx._a * a + mx._c * b;\n\t\tthis._b = mx._b * a + mx._d * b;\n\t\tthis._tx += mx._tx * a + mx._ty * b;\n\t\tthis._c = mx._a * c + mx._c * d;\n\t\tthis._d = mx._b * c + mx._d * d;\n\t\tthis._ty += mx._tx * c + mx._ty * d;\n\t\treturn this;\n\t},\n\n\tpreConcatenate: function(mx) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty;\n\t\tthis._a = mx._a * a + mx._b * c;\n\t\tthis._c = mx._c * a + mx._d * c;\n\t\tthis._b = mx._a * b + mx._b * d;\n\t\tthis._d = mx._c * b + mx._d * d;\n\t\tthis._tx = mx._a * tx + mx._b * ty + mx._tx;\n\t\tthis._ty = mx._c * tx + mx._d * ty + mx._ty;\n\t\treturn this;\n\t},\n\n\ttransform: function( src, srcOff, dst, dstOff, numPts) {\n\t\treturn arguments.length < 5\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, srcOff, dst, dstOff, numPts);\n\t},\n\n\t_transformPoint: function(point, dest, dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point(Point.dont);\n\t\treturn dest.set(\n\t\t\tx * this._a + y * this._b + this._tx,\n\t\t\tx * this._c + y * this._d + this._ty,\n\t\t\tdontNotify\n\t\t);\n\t},\n\n\t_transformCoordinates: function(src, srcOff, dst, dstOff, numPts) {\n\t\tvar i = srcOff, j = dstOff,\n\t\t\tsrcEnd = srcOff + 2 * numPts;\n\t\twhile (i < srcEnd) {\n\t\t\tvar x = src[i++];\n\t\t\tvar y = src[i++];\n\t\t\tdst[j++] = x * this._a + y * this._b + this._tx;\n\t\t\tdst[j++] = x * this._c + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, 0, coords, 0, 4);\n\t},\n\n\t_transformBounds: function(bounds) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = coords.slice(0);\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j])\n\t\t\t\tmin[j] = val;\n\t\t\telse if (val > max[j])\n\t\t\t\tmax[j] = val;\n\t\t}\n\t\treturn Rectangle.create(min[0], min[1],\n\t\t\t\tmax[0] - min[0], max[1] - min[1]);\n\t},\n\n\tinverseTransform: function(point) {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_getDeterminant: function() {\n\t\tvar det = this._a * this._d - this._b * this._c;\n\t\treturn isFinite(det) && Math.abs(det) > Numerical.EPSILON\n\t\t\t\t&& isFinite(this._tx) && isFinite(this._ty)\n\t\t\t\t? det : null;\n\t},\n\n\t_inverseTransform: function(point, dest, dontNotify) {\n\t\tvar det = this._getDeterminant();\n\t\tif (!det)\n\t\t\treturn null;\n\t\tvar x = point.x - this._tx,\n\t\t\ty = point.y - this._ty;\n\t\tif (!dest)\n\t\t\tdest = new Point(Point.dont);\n\t\treturn dest.set(\n\t\t\t(x * this._d - y * this._b) / det,\n\t\t\t(y * this._a - x * this._c) / det,\n\t\t\tdontNotify\n\t\t);\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\tvar hor = Math.sqrt(this._a * this._a + this._c * this._c),\n\t\t\tver = Math.sqrt(this._b * this._b + this._d * this._d);\n\t\treturn new Point(this._a < 0 ? -hor : hor, this._b < 0 ? -ver : ver);\n\t},\n\n\tgetRotation: function() {\n\t\tvar angle1 = -Math.atan2(this._b, this._d),\n\t\t\tangle2 = Math.atan2(this._c, this._a);\n\t\treturn Math.abs(angle1 - angle2) < Numerical.TOLERANCE\n\t\t\t\t? angle1 * 180 / Math.PI : undefined;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a == 1 && this._c == 0 && this._b == 0 && this._d == 1\n\t\t\t\t&& this._tx == 0 && this._ty == 0;\n\t},\n\n\tisInvertible: function() {\n\t\treturn !!this._getDeterminant();\n\t},\n\n\tisSingular: function() {\n\t\treturn !this._getDeterminant();\n\t},\n\n\tcreateInverse: function() {\n\t\tvar det = this._getDeterminant();\n\t\treturn det && Matrix.create(\n\t\t\t\tthis._d / det,\n\t\t\t\t-this._c / det,\n\t\t\t\t-this._b / det,\n\t\t\t\tthis._a / det,\n\t\t\t\t(this._b * this._ty - this._d * this._tx) / det,\n\t\t\t\t(this._c * this._tx - this._a * this._ty) / det);\n\t},\n\n\tcreateShiftless: function() {\n\t\treturn Matrix.create(this._a, this._c, this._b, this._d, 0, 0);\n\t},\n\n\tsetToScale: function(hor, ver) {\n\t\treturn this.set(hor, 0, 0, ver, 0, 0);\n\t},\n\n\tsetToTranslation: function(delta) {\n\t\tdelta = Point.read(arguments);\n\t\treturn this.set(1, 0, 0, 1, delta.x, delta.y);\n\t},\n\n\tsetToShear: function(hor, ver) {\n\t\treturn this.set(1, ver, hor, 1, 0, 0);\n\t},\n\n\tsetToRotation: function(angle, center) {\n\t\tcenter = Point.read(arguments, 1);\n\t\tangle = angle * Math.PI / 180;\n\t\tvar x = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle);\n\t\treturn this.set(cos, sin, -sin, cos,\n\t\t\t\tx - x * cos + y * sin,\n\t\t\t\ty - x * sin - y * cos);\n\t},\n\n\tapplyToContext: function(ctx, reset) {\n\t\tctx[reset ? 'setTransform' : 'transform'](\n\t\t\t\tthis._a, this._c, this._b, this._d, this._tx, this._ty);\n\t\treturn this;\n\t},\n\n\tstatics: {\n\t\tcreate: function(a, c, b, d, tx, ty) {\n\t\t\treturn new Matrix(Matrix.dont).set(a, c, b, d, tx, ty);\n\t\t},\n\n\t\tgetScaleInstance: function(hor, ver) {\n\t\t\tvar mx = new Matrix();\n\t\t\treturn mx.setToScale.apply(mx, arguments);\n\t\t},\n\n\t\tgetTranslateInstance: function(delta) {\n\t\t\tvar mx = new Matrix();\n\t\t\treturn mx.setToTranslation.apply(mx, arguments);\n\t\t},\n\n\t\tgetShearInstance: function(hor, ver, center) {\n\t\t\tvar mx = new Matrix();\n\t\t\treturn mx.setToShear.apply(mx, arguments);\n\t\t},\n\n\t\tgetRotateInstance: function(angle, center) {\n\t\t\tvar mx = new Matrix();\n\t\t\treturn mx.setToRotation.apply(mx, arguments);\n\t\t}\n\t}\n}, new function() {\n\treturn Base.each({\n\t\tscaleX: '_a',\n\t\tscaleY: '_d',\n\t\ttranslateX: '_tx',\n\t\ttranslateY: '_ty',\n\t\tshearX: '_b',\n\t\tshearY: '_c'\n\t}, function(prop, name) {\n\t\tname = Base.capitalize(name);\n\t\tthis['get' + name] = function() {\n\t\t\treturn this[prop];\n\t\t};\n\t\tthis['set' + name] = function(value) {\n\t\t\tthis[prop] = value;\n\t\t};\n\t}, {});\n});\n\nvar Line = this.Line = Base.extend({\n\tinitialize: function(point1, point2, infinite) {\n\t\tpoint1 = Point.read(arguments, 0, 1);\n\t\tpoint2 = Point.read(arguments, 1, 1);\n\t\tif (arguments.length == 3) {\n\t\t\tthis.point = point1;\n\t\t\tthis.vector = point2.subtract(point1);\n\t\t\tthis.infinite = infinite;\n\t\t} else {\n\t\t\tthis.point = point1;\n\t\t\tthis.vector = point2;\n\t\t\tthis.infinite = true;\n\t\t}\n\t},\n\n\tintersect: function(line) {\n\t\tvar cross = this.vector.cross(line.vector);\n\t\tif (Math.abs(cross) <= Numerical.EPSILON)\n\t\t\treturn null;\n\t\tvar v = line.point.subtract(this.point),\n\t\t\tt1 = v.cross(line.vector) / cross,\n\t\t\tt2 = v.cross(this.vector) / cross;\n\t\treturn (this.infinite || 0 <= t1 && t1 <= 1)\n\t\t\t\t&& (line.infinite || 0 <= t2 && t2 <= 1)\n\t\t\t? this.point.add(this.vector.multiply(t1)) : null;\n\t},\n\n\tgetSide: function(point) {\n\t\tvar v1 = this.vector,\n\t\t\tv2 = point.subtract(this.point),\n\t\t\tccw = v2.cross(v1);\n\t\tif (ccw == 0) {\n\t\t\tccw = v2.dot(v1);\n\t\t\tif (ccw > 0) {\n\t\t\t\tccw = v2.subtract(v1).dot(v1);\n\t\t\t\tif (ccw < 0)\n\t\t\t\t    ccw = 0;\n\t\t\t}\n\t\t}\n\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t},\n\n\tgetDistance: function(point) {\n\t\tvar m = this.vector.y / this.vector.x, \n\t\t\tb = this.point.y - (m * this.point.x); \n\t\tvar dist = Math.abs(point.y - (m * point.x) - b) / Math.sqrt(m * m + 1);\n\t\treturn this.infinite ? dist : Math.min(dist,\n\t\t\t\tpoint.getDistance(this.point),\n\t\t\t\tpoint.getDistance(this.point.add(this.vector)));\n\t}\n});\n\nvar Project = this.Project = PaperScopeItem.extend({\n\t_list: 'projects',\n\t_reference: 'project',\n\n\tinitialize: function() {\n\t\tthis.base(true);\n\t\tthis._currentStyle = new PathStyle();\n\t\tthis._selectedItems = {};\n\t\tthis._selectedItemCount = 0;\n\t\tthis.layers = [];\n\t\tthis.symbols = [];\n\t\tthis.activeLayer = new Layer();\n\t},\n\n\t_needsRedraw: function() {\n\t\tif (this._scope)\n\t\t\tthis._scope._needsRedraw();\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.initialize(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetSelectedItems: function() {\n\t\tvar items = [];\n\t\tBase.each(this._selectedItems, function(item) {\n\t\t\titems.push(item);\n\t\t});\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tif (item._selected) {\n\t\t\tthis._selectedItemCount++;\n\t\t\tthis._selectedItems[item.getId()] = item;\n\t\t} else {\n\t\t\tthis._selectedItemCount--;\n\t\t\tdelete this._selectedItems[item.getId()];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tfor (var i = 0, l = this.layers.length; i < l; i++)\n\t\t\tthis.layers[i].setSelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tfor (var i in this._selectedItems)\n\t\t\tthis._selectedItems[i].setSelected(false);\n\t},\n\n\thitTest: function(point, options) {\n\t\toptions = HitResult.getOptions(point, options);\n\t\tpoint = options.point;\n\t\tfor (var i = this.layers.length - 1; i >= 0; i--) {\n\t\t\tvar res = this.layers[i].hitTest(point, options);\n\t\t\tif (res) return res;\n\t\t}\n\t\treturn null;\n\t},\n\n\tdraw: function(ctx) {\n\t\tctx.save();\n\t\tvar param = { offset: new Point(0, 0) };\n\t\tfor (var i = 0, l = this.layers.length; i < l; i++)\n\t\t\tItem.draw(this.layers[i], ctx, param);\n\t\tctx.restore();\n\n\t\tif (this._selectedItemCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tctx.strokeStyle = ctx.fillStyle = '#009dec';\n\t\t\tparam = { selection: true };\n\t\t\tBase.each(this._selectedItems, function(item) {\n\t\t\t\titem.draw(ctx, param);\n\t\t\t});\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Symbol = this.Symbol = Base.extend({\n\tinitialize: function(item) {\n\t\tthis.project = paper.project;\n\t\tthis.project.symbols.push(this);\n\t\tthis.setDefinition(item);\n\t\tthis._instances = {};\n\t},\n\n\t_changed: function(flags) {\n\t\tBase.each(this._instances, function(item) {\n\t\t\titem._changed(flags);\n\t\t});\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(item) {\n\t\tif (item._parentSymbol)\n\t\t\titem = item.clone();\n\t\tif (this._definition)\n\t\t\tdelete this._definition._parentSymbol;\n\t\tthis._definition = item;\n\t\titem.remove();\n\t\titem.setPosition(new Point());\n\t\titem._parentSymbol = this;\n\t\tthis._changed(Change.GEOMETRY);\n\t},\n\n\tplace: function(position) {\n\t\treturn new PlacedSymbol(this, position);\n\t},\n\n\tclone: function() {\n\t \treturn new Symbol(this._definition.clone());\n\t}\n});\n\nvar ChangeFlag = {\n\tAPPEARANCE: 1,\n\tHIERARCHY: 2,\n\tGEOMETRY: 4,\n\tSTROKE: 8,\n\tSTYLE: 16,\n\tATTRIBUTE: 32,\n\tCONTENT: 64,\n\tPIXELS: 128,\n\tCLIPPING: 256\n};\n\nvar Change = {\n\tHIERARCHY: ChangeFlag.HIERARCHY | ChangeFlag.APPEARANCE,\n\tGEOMETRY: ChangeFlag.GEOMETRY | ChangeFlag.APPEARANCE,\n\tSTROKE: ChangeFlag.STROKE | ChangeFlag.STYLE | ChangeFlag.APPEARANCE,\n\tSTYLE: ChangeFlag.STYLE | ChangeFlag.APPEARANCE,\n\tATTRIBUTE: ChangeFlag.ATTRIBUTE | ChangeFlag.APPEARANCE,\n\tCONTENT: ChangeFlag.CONTENT | ChangeFlag.APPEARANCE,\n\tPIXELS: ChangeFlag.PIXELS | ChangeFlag.APPEARANCE\n};\n\nvar Item = this.Item = Base.extend({\n\tinitialize: function() {\n\t\tthis._id = ++Item._id;\n\t\tif (!this._project)\n\t\t\tpaper.project.activeLayer.addChild(this);\n\t\tthis._style = PathStyle.create(this);\n\t\tthis.setStyle(this._project.getCurrentStyle());\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & ChangeFlag.GEOMETRY) {\n\t\t\tdelete this._bounds;\n\t\t\tdelete this._position;\n\t\t}\n\t\tif (flags & ChangeFlag.APPEARANCE) {\n\t\t\tthis._project._needsRedraw();\n\t\t}\n\t\tif (this._parentSymbol)\n\t\t\tthis._parentSymbol._changed(flags);\n\t\tif (this._project._changes) {\n\t\t\tvar entry = this._project._changesById[this._id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tentry = { item: this, flags: flags };\n\t\t\t\tthis._project._changesById[this._id] = entry;\n\t\t\t\tthis._project._changes.push(entry);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeFromNamed();\n\t\tthis._name = name || undefined;\n\t\tif (name) {\n\t\t\tvar children = this._parent._children,\n\t\t\t\tnamedChildren = this._parent._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._changed(ChangeFlag.ATTRIBUTE);\n\t},\n\n\tgetPosition: function() {\n\t\tvar pos = this._position\n\t\t\t\t|| (this._position = this.getBounds().getCenter());\n\t\treturn LinkedPoint.create(this, 'setPosition', pos._x, pos._y);\n\t},\n\n\tsetPosition: function(point) {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition()));\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis._style.initialize(style);\n\t},\n\n\tstatics: {\n\t\t_id: 0\n\t}\n}, new function() { \n\treturn Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\t\tfunction(name) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\tname = '_' + name;\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this[name];\n\t\t\t};\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (value != this[name]) {\n\t\t\t\t\tthis[name] = value;\n\t\t\t\t\tthis._changed(name === '_locked'\n\t\t\t\t\t\t\t? ChangeFlag.ATTRIBUTE : Change.ATTRIBUTE);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {});\n}, {\n\n\t_locked: false,\n\n\t_visible: true,\n\n\t_blendMode: 'normal',\n\n\t_opacity: 1,\n\n\t_guide: false,\n\n\tisSelected: function() {\n\t\tif (this._children) {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tif (this._children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn this._selected;\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._children) {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\tthis._children[i].setSelected(selected);\n\t\t\t}\n\t\t} else if ((selected = !!selected) != this._selected) {\n\t\t\tthis._selected = selected;\n\t\t\tthis._project._updateSelection(this);\n\t\t\tthis._changed(Change.ATTRIBUTE);\n\t\t}\n\t},\n\n\t_selected: false,\n\n\tisFullySelected: function() {\n\t\tif (this._children && this._selected) {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tif (!this._children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn this._selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (this._children) {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\tthis._children[i].setFullySelected(selected);\n\t\t\t}\n\t\t}\n\t\tthis.setSelected(selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(Change.ATTRIBUTE);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(ChangeFlag.CLIPPING);\n\t\t}\n\t},\n\n\t_clipMask: false,\n\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project) {\n\t\tif (this._project != project) {\n\t\t\tthis._project = project;\n\t\t\tif (this._children) {\n\t\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\t\tthis._children[i]._setProject(project);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\treturn this._parent && this._parent._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\treturn this._parent && this._parent._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tclone: function() {\n\t\treturn this._clone(new this.constructor());\n\t},\n\n\t_clone: function(copy) {\n\t\tcopy.setStyle(this._style);\n\t\tif (this._children) {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tcopy.addChild(this._children[i].clone());\n\t\t}\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (this.hasOwnProperty(key))\n\t\t\t\tcopy[key] = this[key];\n\t\t}\n\t\tcopy.setSelected(this._selected);\n\t\tif (this._name)\n\t\t\tcopy.setName(this._name);\n\t\treturn copy;\n\t},\n\n\tcopyTo: function(itemOrProject) {\n\t\tvar copy = this.clone();\n\t\tif (itemOrProject.layers) {\n\t\t\titemOrProject.activeLayer.addChild(copy);\n\t\t} else {\n\t\t\titemOrProject.addChild(copy);\n\t\t}\n\t\treturn copy;\n\t},\n\n\trasterize: function(resolution) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || 72) / 72,\n\t\t\tcanvas = CanvasProvider.getCanvas(bounds.getSize().multiply(scale)),\n\t\t\tctx = canvas.getContext('2d'),\n\t\t\tmatrix = new Matrix().scale(scale).translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tthis.draw(ctx, {});\n\t\tvar raster = new Raster(canvas);\n\t\traster.setBounds(bounds);\n\t\treturn raster;\n\t},\n\n\thitTest: function(point, options, matrix) {\n\t\toptions = HitResult.getOptions(point, options);\n\t\tpoint = options.point;\n\t\tif (!this._children && !this.getRoughBounds(matrix)\n\t\t\t\t.expand(options.tolerance)._containsPoint(point))\n\t\t\treturn null;\n\t\tif ((options.center || options.bounds) &&\n\t\t\t\t!(this instanceof Layer && !this._parent)) {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tthat = this,\n\t\t\t\tpoints = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\t\t\tres;\n\t\t\tfunction checkBounds(type, part) {\n\t\t\t\tvar pt = bounds['get' + part]().transform(matrix);\n\t\t\t\tif (point.getDistance(pt) < options.tolerance)\n\t\t\t\t\treturn new HitResult(type, that,\n\t\t\t\t\t\t\t{ name: Base.hyphenate(part), point: pt });\n\t\t\t}\n\t\t\tif (options.center && (res = checkBounds('center', 'Center')))\n\t\t\t\treturn res;\n\t\t\tif (options.bounds) {\n\t\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\t\tif (res = checkBounds('bounds', points[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\treturn this._children || !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this._selected)\n\t\t\t\t\t? this._hitTest(point, options, matrix) : null;\n\t},\n\n\t_hitTest: function(point, options, matrix) {\n\t\tif (this._children) {\n\t\t\tfor (var i = this._children.length - 1; i >= 0; i--) {\n\t\t\t\tvar res = this._children[i].hitTest(point, options, matrix);\n\t\t\t\tif (res) return res;\n\t\t\t}\n\t\t}\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tif (this._children) {\n\t\t\titem._remove(false, true);\n\t\t\tBase.splice(this._children, [item], index, 0);\n\t\t\titem._parent = this;\n\t\t\titem._setProject(this._project);\n\t\t\tif (item._name)\n\t\t\t\titem.setName(item._name);\n\t\t\tthis._changed(Change.HIERARCHY);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\taddChildren: function(items) {\n\t\tfor (var i = 0, l = items && items.length; i < l; i++)\n\t\t\tthis.insertChild(undefined, items[i]);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tfor (var i = 0, l = items && items.length; i < l; i++) {\n\t\t\tif (this.insertChild(index, items[i]))\n\t\t\t\tindex++;\n\t\t}\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn item._parent && item._parent.insertChild(\n\t\t\t\titem._index + 1, this);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn item._parent && item._parent.insertChild(\n\t\t\t\titem._index - 1, this);\n\t},\n\n\tappendTop: function(item) {\n\t\treturn this.addChild(item);\n\t},\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: function(item) {\n\t\treturn this.insertAbove(item);\n\t},\n\n\tmoveBelow: function(item) {\n\t\treturn this.insertBelow(item);\n\t},\n\n\t_removeFromNamed: function() {\n\t\tvar children = this._parent._children,\n\t\t\tnamedChildren = this._parent._namedChildren,\n\t\t\tname = this._name,\n\t\t\tnamedArray = namedChildren[name],\n\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\tif (index == -1)\n\t\t\treturn;\n\t\tif (children[name] == this)\n\t\t\tdelete children[name];\n\t\tnamedArray.splice(index, 1);\n\t\tif (namedArray.length) {\n\t\t\tchildren[name] = namedArray[namedArray.length - 1];\n\t\t} else {\n\t\t\tdelete namedChildren[name];\n\t\t}\n\t},\n\n\t_remove: function(deselect, notify) {\n\t\tif (this._parent) {\n\t\t\tif (deselect)\n\t\t\t\tthis.setSelected(false);\n\t\t\tif (this._name)\n\t\t\t\tthis._removeFromNamed();\n\t\t\tBase.splice(this._parent._children, null, this._index, 1);\n\t\t\tif (notify)\n\t\t\t\tthis._parent._changed(Change.HIERARCHY);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\tremoveChildren: function(from, to) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tfrom = from || 0;\n\t \tto = Base.pick(to, this._children.length);\n\t\tvar removed = this._children.splice(from, to - from);\n\t\tfor (var i = removed.length - 1; i >= 0; i--)\n\t\t\tremoved[i]._remove(true, false);\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(Change.HIERARCHY);\n\t\treturn removed;\n\t},\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(Change.HIERARCHY);\n\t\t}\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent)\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) == -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) == 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent == item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent == this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent == item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& (parent instanceof Group || parent instanceof CompoundPath)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_getBounds: function(getter, cacheName, args) {\n\t\tvar children = this._children;\n\t\tif (!children || children.length == 0)\n\t\t\treturn new Rectangle();\n\t\tvar x1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tif (child._visible) {\n\t\t\t\tvar rect = child[getter](args[0]);\n\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t}\n\t\t}\n\t\tvar bounds = Rectangle.create(x1, y1, x2 - x1, y2 - y1);\n\t\treturn getter == 'getBounds' ? this._createBounds(bounds) : bounds;\n\t},\n\n\t_createBounds: function(rect) {\n\t\treturn LinkedRectangle.create(this, 'setBounds',\n\t\t\t\trect.x, rect.y, rect.width, rect.height);\n\t},\n\n\tgetBounds: function() {\n\t\treturn this._getBounds('getBounds', '_bounds', arguments);\n\t},\n\n\tsetBounds: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width != 0 ? rect.width / bounds.width : 1,\n\t\t\t\t\tbounds.height != 0 ? rect.height / bounds.height : 1);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\tgetStrokeBounds: function() {\n\t\treturn this._getBounds('getStrokeBounds', '_strokeBounds', arguments);\n\t},\n\n\tgetHandleBounds: function() {\n\t\treturn this._getBounds('getHandleBounds', '_handleBounds', arguments);\n\t},\n\n\tgetRoughBounds: function() {\n\t\treturn this._getBounds('getRoughBounds', '_roughBounds', arguments);\n\t},\n\n\tscale: function(hor, ver , center) {\n\t\tif (arguments.length < 2 || typeof ver === 'object') {\n\t\t\tcenter = ver;\n\t\t\tver = hor;\n\t\t}\n\t\treturn this.transform(new Matrix().scale(hor, ver,\n\t\t\t\tcenter || this.getPosition()));\n\t},\n\n\ttranslate: function(delta) {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\trotate: function(angle, center) {\n\t\treturn this.transform(new Matrix().rotate(angle,\n\t\t\t\tcenter || this.getPosition()));\n\t},\n\n\tshear: function(hor, ver, center) {\n\t\tif (arguments.length < 2 || typeof ver === 'object') {\n\t\t\tcenter = ver;\n\t\t\tver = hor;\n\t\t}\n\t\treturn this.transform(new Matrix().shear(hor, ver,\n\t\t\t\tcenter || this.getPosition()));\n\t},\n\n\ttransform: function(matrix, flags) {\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position,\n\t\t\tchildren = this._children;\n\t\tif (this._transform) {\n\t\t\tthis._transform(matrix, flags);\n\t\t\tthis._changed(Change.GEOMETRY);\n\t\t}\n\t\tif (bounds && matrix.getRotation() % 90 === 0) {\n\t\t\tthis._bounds = this._createBounds(\n\t\t\t\t\tmatrix._transformBounds(bounds));\n\t\t\tthis._position = this._bounds.getCenter();\n\t\t} else if (position) {\n\t\t\tthis._position = matrix._transformPoint(position, position, true);\n\t\t}\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i].transform(matrix, flags);\n\t\treturn this;\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tdelta = rectangle.getCenter().subtract(bounds.getCenter()),\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t},\n\n\ttoString: function() {\n\t\treturn (this.constructor._name || 'Item') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id);\n\t},\n\n\tstatics: {\n\t\tdrawSelectedBounds: function(bounds, ctx, matrix) {\n\t\t\tvar coords = matrix._transformCorners(bounds);\n\t\t\tctx.beginPath();\n\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\tctx[i == 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.rect(coords[i] - 2, coords[++i] - 2, 4, 4);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t},\n\n\t\tdraw: function(item, ctx, param) {\n\t\t\tif (!item._visible || item._opacity == 0)\n\t\t\t\treturn;\n\n\t\t\tvar tempCanvas, parentCtx;\n\t\t\tif (item._blendMode !== 'normal'\n\t\t\t\t\t|| item._opacity < 1\n\t\t\t\t\t&& !(item._segments && (!item.getFillColor()\n\t\t\t\t\t\t\t|| !item.getStrokeColor()))) {\n\t\t\t\tvar bounds = item.getStrokeBounds() || item.getBounds();\n\t\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar itemOffset = bounds.getTopLeft().floor(),\n\t\t\t\t\tsize = bounds.getSize().ceil().add(new Size(1, 1));\n\t\t\t\ttempCanvas = CanvasProvider.getCanvas(size);\n\n\t\t\t\tparentCtx = ctx;\n\n\t\t\t\tctx = tempCanvas.getContext('2d');\n\t\t\t\tctx.save();\n\n\t\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t\t}\n\t\t\tvar savedOffset;\n\t\t\tif (itemOffset) {\n\t\t\t\tsavedOffset = param.offset;\n\t\t\t\tparam.offset = itemOffset;\n\t\t\t}\n\t\t\titem.draw(ctx, param);\n\t\t\tif (itemOffset)\n\t\t\t\tparam.offset = savedOffset;\n\n\t\t\tif (tempCanvas) {\n\n\t\t\t\tctx.restore();\n\n\t\t\t\tif (item._blendMode !== 'normal') {\n\t\t\t\t\tvar pixelOffset = itemOffset.subtract(param.offset);\n\t\t\t\t\tBlendMode.process(item._blendMode, ctx, parentCtx,\n\t\t\t\t\t\titem._opacity, pixelOffset);\n\t\t\t\t} else {\n\t\t\t\t\tparentCtx.save();\n\t\t\t\t\tparentCtx.globalAlpha = item._opacity;\n\t\t\t\t\tparentCtx.drawImage(tempCanvas,\n\t\t\t\t\t\t\titemOffset.x, itemOffset.y);\n\t\t\t\t\tparentCtx.restore();\n\t\t\t\t}\n\n\t\t\t\tCanvasProvider.returnCanvas(tempCanvas);\n\t\t\t}\n\t\t}\n\t}\n}, new function() {\n\n\tvar sets = {\n\t\tdown: {}, drag: {}, up: {}, move: {}\n\t};\n\n\tfunction removeAll(set) {\n\t\tfor (var id in set) {\n\t\t\tvar item = set[id];\n\t\t\titem.remove();\n\t\t\tfor (var type in sets) {\n\t\t\t\tvar other = sets[type];\n\t\t\t\tif (other != set && other[item.getId()])\n\t\t\t\t\tdelete other[item.getId()];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction installHandler(name) {\n\t\tvar handler = 'onMouse' + Base.capitalize(name);\n\t\tvar func = paper.tool[handler];\n\t\tif (!func || !func._installed) {\n\t\t\tvar hash = {};\n\t\t\thash[handler] = function(event) {\n\t\t\t\tif (name === 'up')\n\t\t\t\t\tsets.drag = {};\n\t\t\t\tremoveAll(sets[name]);\n\t\t\t\tsets[name] = {};\n\t\t\t\tif (this.base)\n\t\t\t\t\tthis.base(event);\n\t\t\t};\n\t\t\tpaper.tool.inject(hash);\n\t\t\tpaper.tool[handler]._installed = true;\n\t\t}\n\t}\n\n\treturn Base.each(['down', 'drag', 'up', 'move'], function(name) {\n\t\tthis['removeOn' + Base.capitalize(name)] = function() {\n\t\t\tvar hash = {};\n\t\t\thash[name] = true;\n\t\t\treturn this.removeOn(hash);\n\t\t};\n\t}, {\n\t\tremoveOn: function(obj) {\n\t\t\tfor (var name in obj) {\n\t\t\t\tif (obj[name]) {\n\t\t\t\t\tsets[name][this.getId()] = this;\n\t\t\t\t\tif (name === 'drag')\n\t\t\t\t\t\tinstallHandler('up');\n\t\t\t\t\tinstallHandler(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t});\n});\n\nvar Group = this.Group = Item.extend({\n\tinitialize: function(items) {\n\t\tthis.base();\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis.addChildren(!items || !Array.isArray(items)\n\t\t\t\t|| typeof items[0] !== 'object' ? arguments : items);\n\t},\n\n\t_changed: function(flags) {\n\t\tItem.prototype._changed.call(this, flags);\n\t\tif (flags & (ChangeFlag.HIERARCHY | ChangeFlag.CLIPPING)) {\n\t\t\tdelete this._clipItem;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tif (this._clipItem !== undefined)\n\t\t\treturn this._clipItem;\n\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\tvar child = this._children[i];\n\t\t\tif (child._clipMask)\n\t\t\t\treturn this._clipItem = child;\n\t\t}\n\t\treturn this._clipItem = null;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t\treturn this;\n\t},\n\n\tdraw: function(ctx, param) {\n\t\tvar clipItem = this._getClipItem();\n\t\tif (clipItem)\n\t\t\tItem.draw(clipItem, ctx, param);\n\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\tvar item = this._children[i];\n\t\t\tif (item != clipItem)\n\t\t\t\tItem.draw(item, ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = this.Layer = Group.extend({\n\tinitialize: function(items) {\n\t\tthis._project = paper.project;\n\t\tthis._index = this._project.layers.push(this) - 1;\n\t\tthis.base.apply(this, arguments);\n\t\tthis.activate();\n\t},\n\n\t_remove: function(deselect, notify) {\n\t\tif (this._parent)\n\t\t\treturn this.base(deselect, notify);\n\t\tif (this._index != null) {\n\t\t\tif (deselect)\n\t\t\t\tthis.setSelected(false);\n\t\t\tBase.splice(this._project.layers, null, this._index, 1);\n\t\t\tthis._project._needsRedraw();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetNextSibling: function() {\n\t\treturn this._parent ? this.base()\n\t\t\t\t: this._project.layers[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\treturn this._parent ? this.base()\n\t\t\t\t: this._project.layers[this._index - 1] || null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project.activeLayer = this;\n\t}\n}, new function () {\n\tfunction insert(above) {\n\t\treturn function(item) {\n\t\t\tif (item instanceof Layer && !item._parent\n\t\t\t\t\t\t&& this._remove(false, true)) {\n\t\t\t\tBase.splice(item._project.layers, [this],\n\t\t\t\t\t\titem._index + (above ? 1 : -1), 0);\n\t\t\t\tthis._setProject(item._project);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this.base(item);\n\t\t};\n\t}\n\n\treturn {\n\t\tinsertAbove: insert(true),\n\n\t\tinsertBelow: insert(false)\n\t};\n});\n\nvar PlacedItem = this.PlacedItem = Item.extend({\n\n\t_transform: function(matrix, flags) {\n\t\tthis._matrix.preConcatenate(matrix);\n\t},\n\n\t_changed: function(flags) {\n\t\tItem.prototype._changed.call(this, flags);\n\t\tif (flags & ChangeFlag.GEOMETRY) {\n\t\t\tdelete this._strokeBounds;\n\t\t\tdelete this._handleBounds;\n\t\t\tdelete this._roughBounds;\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function(matrix) {\n\t\tthis._matrix = matrix.clone();\n\t\tthis._changed(Change.GEOMETRY);\n\t},\n\n\tgetBounds: function() {\n\t\tvar useCache = arguments[0] === undefined;\n\t\tif (useCache && this._bounds)\n\t\t\treturn this._bounds;\n\t\tvar bounds = this.getStrokeBounds(arguments[0]);\n\t\tif (useCache)\n\t\t\tbounds = this._bounds = this._createBounds(bounds);\n\t\treturn bounds;\n\t},\n\n\t_getBounds: function(getter, cacheName, args) {\n\t\tvar matrix = args[0],\n\t\t\tuseCache = matrix === undefined;\n\t\tif (useCache && this[cacheName])\n\t\t\treturn this[cacheName];\n\t\tmatrix = matrix ? matrix.clone().concatenate(this._matrix)\n\t\t\t\t: this._matrix;\n\t\tvar bounds = this._calculateBounds(getter, matrix);\n\t\tif (useCache)\n\t\t\tthis[cacheName] = bounds;\n\t\treturn bounds;\n\t}\n});\n\nvar Raster = this.Raster = PlacedItem.extend({\n\tinitialize: function(object) {\n\t\tthis.base();\n\t\tif (object.getContext) {\n\t\t\tthis.setCanvas(object);\n\t\t} else {\n\t\t\tif (typeof object === 'string')\n\t\t\t\tobject = document.getElementById(object);\n\t\t\tthis.setImage(object);\n\t\t}\n\t\tthis._matrix = new Matrix();\n\t},\n\n\tclone: function() {\n\t\tvar image = this._image;\n\t\tif (!image) {\n\t\t\timage = CanvasProvider.getCanvas(this._size);\n\t\t\timage.getContext('2d').drawImage(this._canvas, 0, 0);\n\t\t}\n\t\tvar copy = new Raster(image);\n\t\tcopy._matrix = this._matrix.clone();\n\t\treturn this._clone(copy);\n\t},\n\n\tgetSize: function() {\n\t\treturn this._size;\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\timage = this.getImage();\n\t\tthis.setCanvas(CanvasProvider.getCanvas(size));\n\t\tthis.getContext(true).drawImage(image, 0, 0, size.width, size.height);\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size.width;\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size.height;\n\t},\n\n\tgetPpi: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetContext: function() {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (arguments[0])\n\t\t\tthis._changed(Change.PIXELS);\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tthis._canvas = CanvasProvider.getCanvas(this._size);\n\t\t\tif (this._image)\n\t\t\t\tthis.getContext(true).drawImage(this._image, 0, 0);\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: function(canvas) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.returnCanvas(this._canvas);\n\t\tthis._canvas = canvas;\n\t\tthis._size = new Size(canvas.width, canvas.height);\n\t\tthis._image = null;\n\t\tthis._context = null;\n\t\tthis._changed(Change.GEOMETRY);\n\t},\n\n\tgetImage: function() {\n\t\treturn this._image || this.getCanvas();\n\t},\n\n\tsetImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.returnCanvas(this._canvas);\n\t\tthis._image = image;\n\t\tthis._size = new Size(image.naturalWidth, image.naturalHeight);\n\t\tthis._canvas = null;\n\t\tthis._context = null;\n\t\tthis._changed(Change.GEOMETRY);\n\t},\n\n\tgetSubImage: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\tvar canvas = CanvasProvider.getCanvas(rect.getSize());\n\t\tcanvas.getContext('2d').drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\tcanvas.width, canvas.height, 0, 0, canvas.width, canvas.height);\n\t\treturn canvas;\n\t},\n\n\tdrawImage: function(image, point) {\n\t\tpoint = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tif (!object)\n\t\t\tobject = this.getBounds();\n\t\tvar bounds, path;\n\t\tif (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (object.width) {\n\t\t\tbounds = new Rectangle(object);\n\t\t} else if (object.x) {\n\t\t\tbounds = Rectangle.create(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t}\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getCanvas(\n\t\t\t\t\tnew Size(sampleSize)).getContext('2d');\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize, sampleSize);\n\t\t}\n\t\tctx.save();\n\t\tctx.scale(width / bounds.width, height / bounds.height);\n\t\tctx.translate(-bounds.x, -bounds.y);\n\t\tif (path)\n\t\t\tpath.draw(ctx, { clip: true });\n\t\tthis._matrix.applyToContext(ctx);\n\t\tctx.drawImage(this._canvas || this._image,\n\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tvar pixels = this.getContext().getImageData(point.x, point.y, 1, 1).data,\n\t\t\tchannels = new Array(4);\n\t\tfor (var i = 0; i < 4; i++)\n\t\t\tchannels[i] = pixels[i] / 255;\n\t\treturn RgbColor.read(channels);\n\t},\n\n\tsetPixel: function(point, color) {\n\t\tvar hasPoint = arguments.length == 2;\n\t\tpoint = Point.read(arguments, 0, hasPoint ? 1 : 2);\n\t\tcolor = Color.read(arguments, hasPoint ? 1 : 2);\n\t\tvar ctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\talpha = color.getAlpha();\n\t\timageData.data[0] = color.getRed() * 255;\n\t\timageData.data[1] = color.getGreen() * 255;\n\t\timageData.data[2] = color.getBlue() * 255;\n\t\timageData.data[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateData: function(size) {\n\t\tsize = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetData: function(rect) {\n\t\trect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this.getSize());\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetData: function(data, point) {\n\t\tpoint = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_calculateBounds: function(getter, matrix) {\n\t\treturn matrix._transformBounds(\n\t\t\t\tnew Rectangle(this._size).setCenter(0, 0));\n\t},\n\n\tgetHandleBounds: function() {\n\t\treturn this.getStrokeBounds(arguments[0]);\n\t},\n\n\tgetRoughBounds: function() {\n\t\treturn this.getStrokeBounds(arguments[0]);\n\t},\n\n\tdraw: function(ctx, param) {\n\t\tif (param.selection) {\n\t\t\tvar bounds = new Rectangle(this._size).setCenter(0, 0);\n\t\t\tItem.drawSelectedBounds(bounds, ctx, this._matrix);\n\t\t} else {\n\t\t\tctx.save();\n\t\t\tthis._matrix.applyToContext(ctx);\n\t\t\tctx.drawImage(this._canvas || this._image,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar PlacedSymbol = this.PlacedSymbol = PlacedItem.extend({\n\tinitialize: function(symbol, matrixOrOffset) {\n\t\tthis.base();\n\t\tthis.setSymbol(symbol instanceof Symbol ? symbol : new Symbol(symbol));\n\t\tthis._matrix = matrixOrOffset !== undefined\n\t\t\t? matrixOrOffset instanceof Matrix\n\t\t\t\t? matrixOrOffset\n\t\t\t\t: new Matrix().translate(Point.read(arguments, 1))\n\t\t\t: new Matrix();\n\t},\n\n\tgetSymbol: function() {\n\t\treturn this._symbol;\n\t},\n\n\tsetSymbol: function(symbol) {\n\t\tif (this._symbol)\n\t\t\tdelete this._symbol._instances[this._id];\n\t\tthis._symbol = symbol;\n\t\tsymbol._instances[this._id] = this;\n\t},\n\n\tclone: function() {\n\t\treturn this._clone(new PlacedSymbol(this.symbol, this._matrix.clone()));\n\t},\n\n\t_calculateBounds: function(getter, matrix) {\n\t\treturn this.symbol._definition[getter](matrix);\n\t},\n\n\tdraw: function(ctx, param) {\n\t\tif (param.selection) {\n\t\t\tItem.drawSelectedBounds(this.symbol._definition.getStrokeBounds(),\n\t\t\t\t\tctx, this._matrix);\n\t\t} else {\n\t\t\tctx.save();\n\t\t\tthis._matrix.applyToContext(ctx);\n\t\t\tItem.draw(this.symbol.getDefinition(), ctx, param);\n\t\t\tctx.restore();\n\t\t}\n\t}\n\n});\n\nHitResult = Base.extend({\n\tinitialize: function(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values) {\n\t\t\tBase.each(values, function(value, key) {\n\t\t\t\tthis[key] = value;\n\t\t\t}, this);\n\t\t}\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(point, options) {\n\t\t\treturn options && options._merged ? options : Base.merge({\n\t\t\t\tpoint: Point.read(arguments, 0, 1),\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: 2,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false,\n\t\t\t\t_merged: true\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = this.Segment = Base.extend({\n\tinitialize: function(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tcreatePoint = SegmentPoint.create,\n\t\t\tpoint, handleIn, handleOut;\n\t\tif (count == 0) {\n\t\t} else if (count == 1) {\n\t\t\tif (arg0.point) {\n\t\t\t\tpoint = arg0.point;\n\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t} else {\n\t\t\t\tpoint = arg0;\n\t\t\t}\n\t\t} else if (count < 6) {\n\t\t\tif (count == 2 && arg1.x === undefined) {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t} else {\n\t\t\t\tpoint = arg0;\n\t\t\t\thandleIn = arg1;\n\t\t\t\thandleOut = arg2;\n\t\t\t}\n\t\t} else if (count == 6) {\n\t\t\tpoint = [ arg0, arg1 ];\n\t\t\thandleIn = [ arg2, arg3 ];\n\t\t\thandleOut = [ arg4, arg5 ];\n\t\t}\n\t\tcreatePoint(this, '_point', point);\n\t\tcreatePoint(this, '_handleIn', handleIn);\n\t\tcreatePoint(this, '_handleOut', handleOut);\n\t},\n\n\t_changed: function(point) {\n\t\tif (!this._path)\n\t\t\treturn;\n\t\tvar curve = this._path._curves && this.getCurve(), other;\n\t\tif (curve) {\n\t\t\tcurve._changed();\n\t\t\tif (other = (curve[point == this._point\n\t\t\t\t\t|| point == this._handleIn && curve._segment1 == this\n\t\t\t\t\t? 'getPrevious' : 'getNext']())) {\n\t\t\t\tother._changed();\n\t\t\t}\n\t\t}\n\t\tthis._path._changed(Change.GEOMETRY);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._point.set(point.x, point.y);\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._handleIn.set(point.x, point.y);\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._handleOut.set(point.x, point.y);\n\t},\n\n\t_isSelected: function(point) {\n\t\tvar state = this._selectionState;\n\t\treturn point == this._point ? !!(state & SelectionState.POINT)\n\t\t\t: point == this._handleIn ? !!(state & SelectionState.HANDLE_IN)\n\t\t\t: point == this._handleOut ? !!(state & SelectionState.HANDLE_OUT)\n\t\t\t: false;\n\t},\n\n\t_setSelected: function(point, selected) {\n\t\tvar path = this._path,\n\t\t\tselected = !!selected, \n\t\t\tstate = this._selectionState || 0,\n\t\t\tselection = [\n\t\t\t\t!!(state & SelectionState.POINT),\n\t\t\t\t!!(state & SelectionState.HANDLE_IN),\n\t\t\t\t!!(state & SelectionState.HANDLE_OUT)\n\t\t\t];\n\t\tif (point == this._point) {\n\t\t\tif (selected) {\n\t\t\t\tselection[1] = selection[2] = false;\n\t\t\t} else {\n\t\t\t\tvar previous = this.getPrevious(),\n\t\t\t\t\tnext = this.getNext();\n\t\t\t\tselection[1] = previous && (previous._point.isSelected()\n\t\t\t\t\t\t|| previous._handleOut.isSelected());\n\t\t\t\tselection[2] = next && (next._point.isSelected()\n\t\t\t\t\t\t|| next._handleIn.isSelected());\n\t\t\t}\n\t\t\tselection[0] = selected;\n\t\t} else {\n\t\t\tvar index = point == this._handleIn ? 1 : 2;\n\t\t\tif (selection[index] != selected) {\n\t\t\t\tif (selected)\n\t\t\t\t\tselection[0] = false;\n\t\t\t\tselection[index] = selected;\n\t\t\t\tpath._changed(Change.ATTRIBUTE);\n\t\t\t}\n\t\t}\n\t\tthis._selectionState = (selection[0] ? SelectionState.POINT : 0)\n\t\t\t\t| (selection[1] ? SelectionState.HANDLE_IN : 0)\n\t\t\t\t| (selection[2] ? SelectionState.HANDLE_OUT : 0);\n\t\tif (path && state != this._selectionState)\n\t\t\tpath._updateSelection(this, state, this._selectionState);\n\t},\n\n\tisSelected: function() {\n\t\treturn this._isSelected(this._point);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._setSelected(this._point, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tif (this._path) {\n\t\t\tvar index = this._index;\n\t\t\tif (!this._path._closed && index == this._path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn this._path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\treverse: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn =  !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (!matrix)\n\t\t\treturn;\n\t\tmatrix._transformCoordinates(coords, 0, coords, 0, i / 2);\n\t\tx = coords[0];\n\t\ty = coords[1];\n\t\tif (change) {\n\t\t\tpoint._x = x;\n\t\t\tpoint._y = y;\n\t\t\ti  = 2;\n\t\t\tif (handleIn) {\n\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t}\n\t\t\tif (handleOut) {\n\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!handleIn) {\n\t\t\t\tcoords[i++] = x;\n\t\t\t\tcoords[i++] = y;\n\t\t\t}\n\t\t\tif (!handleOut) {\n\t\t\t\tcoords[i++] = x;\n\t\t\t\tcoords[i++] = y;\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tset: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\treturn this._x == 0 && this._y == 0;\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._setSelected(this, selected);\n\t},\n\n\tisSelected: function() {\n\t\treturn this._owner._isSelected(this);\n\t},\n\n\tstatics: {\n\t\tcreate: function(segment, key, pt) {\n\t\t\tvar point = new SegmentPoint(SegmentPoint.dont),\n\t\t\t\tx, y, selected;\n\t\t\tif (!pt) {\n\t\t\t\tx = y = 0;\n\t\t\t} else if ((x = pt[0]) !== undefined) { \n\t\t\t\ty = pt[1];\n\t\t\t} else {\n\t\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\t\tpt = Point.read(arguments, 2, 1);\n\t\t\t\t\tx = pt.x;\n\t\t\t\t}\n\t\t\t\ty = pt.y;\n\t\t\t\tselected = pt.selected;\n\t\t\t}\n\t\t\tpoint._x = x;\n\t\t\tpoint._y = y;\n\t\t\tpoint._owner = segment;\n\t\t\tsegment[key] = point;\n\t\t\tif (selected)\n\t\t\t\tpoint.setSelected(true);\n\t\t\treturn point;\n\t\t}\n\t}\n});\n\nvar SelectionState = {\n\tHANDLE_IN: 1,\n\tHANDLE_OUT: 2,\n\tPOINT: 4\n};\n\nvar Curve = this.Curve = Base.extend({\n\tinitialize: function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length;\n\t\tif (count == 0) {\n\t\t\tthis._segment1 = new Segment();\n\t\t\tthis._segment2 = new Segment();\n\t\t} else if (count == 1) {\n\t\t\tthis._segment1 = new Segment(arg0.segment1);\n\t\t\tthis._segment2 = new Segment(arg0.segment2);\n\t\t} else if (count == 2) {\n\t\t\tthis._segment1 = new Segment(arg0);\n\t\t\tthis._segment2 = new Segment(arg1);\n\t\t} else if (count == 4) {\n\t\t\tthis._segment1 = new Segment(arg0, null, arg1);\n\t\t\tthis._segment2 = new Segment(arg3, arg2, null);\n\t\t} else if (count == 8) {\n\t\t\tvar p1 = Point.create(arg0, arg1),\n\t\t\t\tp2 = Point.create(arg6, arg7);\n\t\t\tthis._segment1 = new Segment(p1, null,\n\t\t\t\t\tPoint.create(arg2, arg3).subtract(p1));\n\t\t\tthis._segment2 = new Segment(p2,\n\t\t\t\t\tPoint.create(arg4, arg5).subtract(p2), null);\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tdelete this._length;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._segment1._point.set(point.x, point.y);\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._segment2._point.set(point.x, point.y);\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._segment1._handleOut.set(point.x, point.y);\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function(point) {\n\t\tpoint = Point.read(arguments);\n\t\tthis._segment2._handleIn.set(point.x, point.y);\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getHandle1().isSelected() && this.getHandle2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function(matrix) {\n\t\tvar coords = this.getValues(matrix),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(Point.create(coords[i], coords[i + 1]));\n\t\treturn points;\n\t},\n\n\tgetLength: function() {\n\t\tvar from = arguments[0],\n\t\t\tto = arguments[1];\n\t\t\tfullLength = arguments.length == 0 || from == 0 && to == 1;\n\t\tif (fullLength && this._length != null)\n\t\t\treturn this._length;\n\t\tvar length = Curve.getLength(this.getValues(), from, to);\n\t\tif (fullLength)\n\t\t\tthis._length = length;\n\t\treturn length;\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tisLinear: function() {\n\t\treturn this._segment1._handleOut.isZero()\n\t\t\t\t&& this._segment2._handleIn.isZero();\n\t},\n\n\tgetParameterAt: function(offset, start) {\n\t\treturn Curve.getParameterAt(this.getValues(), offset,\n\t\t\t\tstart !== undefined ? start : offset < 0 ? 1 : 0);\n\t},\n\n\tgetPoint: function(parameter) {\n\t\treturn Curve.evaluate(this.getValues(), parameter, 0);\n\t},\n\n\tgetTangent: function(parameter) {\n\t\treturn Curve.evaluate(this.getValues(), parameter, 1);\n\t},\n\n\tgetNormal: function(parameter) {\n\t\treturn Curve.evaluate(this.getValues(), parameter, 2);\n\t},\n\n\tgetParameter: function(point) {\n\t\tpoint = Point.read(point);\n\t\treturn Curve.getParameter(this.getValues(), point.x, point.y);\n\t},\n\n\tgetCrossings: function(point, matrix, roots) {\n\t\tvar vals = this.getValues(matrix),\n\t\t\tnum = Curve.solveCubic(vals, 1, point.y, roots),\n\t\t\tcrossings = 0;\n\t\tfor (var i = 0; i < num; i++) {\n\t\t\tvar t = roots[i];\n\t\t\tif (t >= 0 && t < 1 && Curve.evaluate(vals, t, 0).x > point.x) {\n\t\t\t\tif (t < Numerical.TOLERANCE && Curve.evaluate(\n\t\t\t\t\t\t\tthis.getPrevious().getValues(matrix), 1, 1).y\n\t\t\t\t\t\t* Curve.evaluate(vals, t, 1).y >= 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tcrossings++;\n\t\t\t}\n\t\t}\n\t\treturn crossings;\n\t},\n\n\treverse: function() {\n\t\treturn new Curve(this._segment2.reverse(), this._segment1.reverse());\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tstatics: {\n\t\tcreate: function(path, segment1, segment2) {\n\t\t\tvar curve = new Curve(Curve.dont);\n\t\t\tcurve._path = path;\n\t\t\tcurve._segment1 = segment1;\n\t\t\tcurve._segment2 = segment2;\n\t\t\treturn curve;\n\t\t},\n\n\t\tgetValues: function(segment1, segment2, matrix) {\n\t\t\tvar p1 = segment1._point,\n\t\t\t\th1 = segment1._handleOut,\n\t\t\t\th2 = segment2._handleIn,\n\t\t\t\tp2 = segment2._point,\n\t\t\t\tcoords = [\n\t\t\t\t\tp1._x, p1._y,\n\t\t\t\t\tp1._x + h1._x, p1._y + h1._y,\n\t\t\t\t\tp2._x + h2._x, p2._y + h2._y,\n\t\t\t\t\tp2._x, p2._y\n\t\t\t\t];\n\t\t\treturn matrix\n\t\t\t\t\t? matrix._transformCoordinates(coords, 0, coords, 0, 4)\n\t\t\t\t\t: coords;\n\t\t},\n\n\t\tevaluate: function(v, t, type) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\t\t\t\tx, y;\n\n\t\t\tif (type == 0 && (t == 0 || t == 1)) {\n\t\t\t\tx = t == 0 ? p1x : p2x;\n\t\t\t\ty = t == 0 ? p1y : p2y;\n\t\t\t} else {\n\t\t\t\tvar tMin = Numerical.TOLERANCE;\n\t\t\t\tif (t < tMin && c1x == p1x && c1y == p1y)\n\t\t\t\t\tt = tMin;\n\t\t\t\telse if (t > 1 - tMin && c2x == p2x && c2y == p2y)\n\t\t\t\t\tt = 1 - tMin;\n\t\t\t\tvar cx = 3 * (c1x - p1x),\n\t\t\t\t\tbx = 3 * (c2x - c1x) - cx,\n\t\t\t\t\tax = p2x - p1x - cx - bx,\n\n\t\t\t\t\tcy = 3 * (c1y - p1y),\n\t\t\t\t\tby = 3 * (c2y - c1y) - cy,\n\t\t\t\t\tay = p2y - p1y - cy - by;\n\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 0: \n\t\t\t\t\tx = ((ax * t + bx) * t + cx) * t + p1x;\n\t\t\t\t\ty = ((ay * t + by) * t + cy) * t + p1y;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: \n\t\t\t\tcase 2: \n\t\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn type == 2 ? new Point(y, -x) : new Point(x, y);\n\t\t},\n\n\t\tsubdivide: function(v, t) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7];\n\t\t\tif (t === undefined)\n\t\t\t\tt = 0.5;\n\t\t\tvar u = 1 - t,\n\t\t\t\tp3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,\n\t\t\t\tp4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,\n\t\t\t\tp5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,\n\t\t\t\tp6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,\n\t\t\t\tp7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,\n\t\t\t\tp8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;\n\t\t\treturn [\n\t\t\t\t[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y], \n\t\t\t\t[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y] \n\t\t\t];\n\t\t},\n\n\t\tsolveCubic: function (v, coord, val, roots) {\n\t\t\tvar p1 = v[coord],\n\t\t\t\tc1 = v[coord + 2],\n\t\t\t\tc2 = v[coord + 4],\n\t\t\t\tp2 = v[coord + 6],\n\t\t\t\tc = 3 * (c1 - p1),\n\t\t\t\tb = 3 * (c2 - c1) - c,\n\t\t\t\ta = p2 - p1 - c - b;\n\t\t\treturn Numerical.solveCubic(a, b, c, p1 - val, roots,\n\t\t\t\t\tNumerical.TOLERANCE);\n\t\t},\n\n\t\tgetParameter: function(v, x, y) {\n\t\t\tvar txs = [],\n\t\t\t\ttys = [],\n\t\t\t\tsx = Curve.solveCubic(v, 0, x, txs),\n\t\t\t\tsy = Curve.solveCubic(v, 1, y, tys),\n\t\t\t\ttx, ty;\n\t\t\tfor (var cx = 0;  sx == -1 || cx < sx;) {\n\t\t\t\tif (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {\n\t\t\t\t\tfor (var cy = 0; sy == -1 || cy < sy;) {\n\t\t\t\t\t\tif (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {\n\t\t\t\t\t\t\tif (sx == -1) tx = ty;\n\t\t\t\t\t\t\telse if (sy == -1) ty = tx;\n\t\t\t\t\t\t\tif (Math.abs(tx - ty) < Numerical.TOLERANCE)\n\t\t\t\t\t\t\t\treturn (tx + ty) * 0.5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sx == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\t\tgetPart: function(v, from, to) {\n\t\t\tif (from > 0)\n\t\t\t\tv = Curve.subdivide(v, from)[1]; \n\t\t\tif (to < 1)\n\t\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0]; \n\t\t\treturn v;\n\t\t},\n\n\t\tisFlatEnough: function(v) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\n\t\t\t\ta = p1y - p2y,\n\t\t\t\tb = p2x - p1x,\n\t\t\t\tc = p1x * p2y - p2x * p1y,\n\t\t\t\tv1 = a * c1x + b * c1y + c,\n\t\t\t\tv2 = a * c2x + b * c2y + c;\n\t\t\treturn Math.abs((v1 * v1 + v2 * v2) / (a * (a * a + b * b))) < 0.005;\n\t\t}\n\t}\n}, new function() { \n\n\tfunction getLengthIntegrand(v) {\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tc1x = v[2], c1y = v[3],\n\t\t\tc2x = v[4], c2y = v[5],\n\t\t\tp2x = v[6], p2y = v[7],\n\n\t\t\tax = 9 * (c1x - c2x) + 3 * (p2x - p1x),\n\t\t\tbx = 6 * (p1x + c2x) - 12 * c1x,\n\t\t\tcx = 3 * (c1x - p1x),\n\n\t\t\tay = 9 * (c1y - c2y) + 3 * (p2y - p1y),\n\t\t\tby = 6 * (p1y + c2y) - 12 * c1y,\n\t\t\tcy = 3 * (c1y - p1y);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\treturn {\n\t\tstatics: true,\n\n\t\tgetLength: function(v, a, b) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (v[0] == v[2] && v[1] == v[3] && v[6] == v[4] && v[7] == v[5]) {\n\t\t\t\tvar dx = v[6] - v[0], \n\t\t\t\t\tdy = v[7] - v[1]; \n\t\t\t\treturn (b - a) * Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\tvar ds = getLengthIntegrand(v);\n\t\t\treturn Numerical.integrate(ds, a, b, getIterations(a, b));\n\t\t},\n\n\t\tgetParameterAt: function(v, offset, start) {\n\t\t\tif (offset == 0)\n\t\t\t\treturn start;\n\t\t\tvar forward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\toffset = Math.abs(offset),\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Numerical.integrate(ds, a, b,\n\t\t\t\t\t\tgetIterations(a, b));\n\t\t\tif (offset >= rangeLength)\n\t\t\t\treturn forward ? b : a;\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tvar count = getIterations(start, t);\n\t\t\t\tlength += start < t\n\t\t\t\t\t\t? Numerical.integrate(ds, start, t, count)\n\t\t\t\t\t\t: -Numerical.integrate(ds, t, start, count);\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds,\n\t\t\t\t\tforward ? a + guess : b - guess, \n\t\t\t\t\ta, b, 16, Numerical.TOLERANCE);\n\t\t}\n\t};\n}, new function() { \n\n\tvar maxDepth = 32,\n\t\tepsilon = Math.pow(2, -maxDepth - 1);\n\n\tvar zCubic = [\n\t\t[1.0, 0.6, 0.3, 0.1],\n\t\t[0.4, 0.6, 0.6, 0.4],\n\t\t[0.1, 0.3, 0.6, 1.0]\n\t];\n\n\tvar xAxis = new Line(new Point(0, 0), new Point(1, 0));\n\n\tfunction toBezierForm(v, point) {\n\t\tvar n = 3, \n\t \t\tdegree = 5, \n\t\t\tc = [],\n\t\t\td = [],\n\t\t\tcd = [],\n\t\t\tw = [];\n\t\tfor(var i = 0; i <= n; i++) {\n\t\t\tc[i] = v[i].subtract(point);\n\t\t\tif (i < n)\n\t\t\t\td[i] = v[i + 1].subtract(v[i]).multiply(n);\n\t\t}\n\n\t\tfor (var row = 0; row < n; row++) {\n\t\t\tcd[row] = [];\n\t\t\tfor (var column = 0; column <= n; column++)\n\t\t\t\tcd[row][column] = d[row].dot(c[column]);\n\t\t}\n\n\t\tfor (var i = 0; i <= degree; i++)\n\t\t\tw[i] = new Point(i / degree, 0);\n\n\t\tfor (k = 0; k <= degree; k++) {\n\t\t\tvar lb = Math.max(0, k - n + 1),\n\t\t\t\tub = Math.min(k, n);\n\t\t\tfor (var i = lb; i <= ub; i++) {\n\t\t\t\tvar j = k - i;\n\t\t\t\tw[k].y += cd[j][i] * zCubic[j][i];\n\t\t\t}\n\t\t}\n\n\t\treturn w;\n\t}\n\n\tfunction findRoots(w, depth) {\n\t\tswitch (countCrossings(w)) {\n\t\tcase 0:\n\t\t\treturn [];\n\t\tcase 1:\n\t\t\tif (depth >= maxDepth)\n\t\t\t\treturn [0.5 * (w[0].x + w[5].x)];\n\t\t\tif (isFlatEnough(w)) {\n\t\t\t\tvar line = new Line(w[0], w[5], true);\n\t\t\t\treturn [ line.vector.getLength(true) <= Numerical.EPSILON\n\t\t\t\t\t\t? line.point.x\n\t\t\t\t\t\t: xAxis.intersect(line).x ];\n\t\t\t}\n\t\t}\n\n\t\tvar p = [[]],\n\t\t\tleft = [],\n\t\t\tright = [];\n\t\tfor (var j = 0; j <= 5; j++)\n\t\t \tp[0][j] = new Point(w[j]);\n\n\t\tfor (var i = 1; i <= 5; i++) {\n\t\t\tp[i] = [];\n\t\t\tfor (var j = 0 ; j <= 5 - i; j++)\n\t\t\t\tp[i][j] = p[i - 1][j].add(p[i - 1][j + 1]).multiply(0.5);\n\t\t}\n\t\tfor (var j = 0; j <= 5; j++) {\n\t\t\tleft[j]  = p[j][0];\n\t\t\tright[j] = p[5 - j][j];\n\t\t}\n\n\t\treturn findRoots(left, depth + 1).concat(findRoots(right, depth + 1));\n\t}\n\n\tfunction countCrossings(v) {\n\t\tvar crossings = 0,\n\t\t\tprevSign = null;\n\t\tfor (var i = 0, l = v.length; i < l; i++)  {\n\t\t\tvar sign = v[i].y < 0 ? -1 : 1;\n\t\t\tif (prevSign != null && sign != prevSign)\n\t\t\t\tcrossings++;\n\t\t\tprevSign = sign;\n\t\t}\n\t\treturn crossings;\n\t}\n\n\tfunction isFlatEnough(v) {\n\n\t\tvar n = v.length - 1,\n\t\t\ta = v[0].y - v[n].y,\n\t\t\tb = v[n].x - v[0].x,\n\t\t\tc = v[0].x * v[n].y - v[n].x * v[0].y,\n\t\t\tmaxAbove = 0,\n\t\t\tmaxBelow = 0;\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tvar val = a * v[i].x + b * v[i].y + c,\n\t\t\t\tdist = val * val;\n\t\t\tif (val < 0 && dist > maxBelow) {\n\t\t\t\tmaxBelow = dist;\n\t\t\t} else if (dist > maxAbove) {\n\t\t\t\tmaxAbove = dist;\n\t\t\t}\n\t\t}\n\t\treturn Math.abs((maxAbove + maxBelow) / (2 * a * (a * a + b * b)))\n\t\t\t\t< epsilon;\n\t}\n\n\treturn {\n\t\tgetNearestLocation: function(point, matrix) {\n\t\t\tvar w = toBezierForm(this.getPoints(matrix), point);\n\t\t\tvar roots = findRoots(w, 0).concat([0, 1]);\n\t\t\tvar minDist = Infinity,\n\t\t\t\tminT,\n\t\t\t\tminPoint;\n\t\t\tfor (var i = 0; i < roots.length; i++) {\n\t\t\t\tvar pt = this.getPoint(roots[i]),\n\t\t\t\t\tdist = point.getDistance(pt, true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = roots[i];\n\t\t\t\t\tminPoint = pt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new CurveLocation(this, minT, minPoint, Math.sqrt(minDist));\n\t\t},\n\n\t\tgetNearestPoint: function(point, matrix) {\n\t\t\treturn this.getNearestLocation(point, matrix).getPoint();\n\t\t}\n\t};\n});\n\nCurveLocation = Base.extend({\n\tinitialize: function(curve, parameter, point, distance) {\n\t\tthis._curve = curve;\n\t\tthis._parameter = parameter;\n\t\tthis._point = point;\n\t\tthis._distance = distance;\n\t},\n\n\tgetSegment: function() {\n\t\tif (!this._segment) {\n\t\t\tvar curve = this._curve,\n\t\t\t\tparameter = this.getParameter();\n\t\t\tif (parameter == 0) {\n\t\t\t\tthis._segment = curve._segment1;\n\t\t\t} else if (parameter == 1) {\n\t\t\t\tthis._segment = curve._segment2;\n\t\t\t} else if (parameter == null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tthis._segment = curve.getLength(0, parameter)\n\t\t\t\t\t< curve.getLength(parameter, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t}\n\t\treturn this._segment;\n\t},\n\n\tgetCurve: function() {\n\t\treturn this._curve;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._curve && this._curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._curve && this._curve.getIndex();\n\t},\n\n\tgetOffset: function() {\n\t\tvar path = this._curve && this._curve._path;\n\t\treturn path && path._getOffset(this);\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar parameter = this.getParameter();\n\t\treturn parameter != null && this._curve\n\t\t\t\t&& this._curve.getLength(0, parameter);\n\t},\n\n\tgetParameter: function() {\n\t\tif (this._parameter == null && this._curve && this._point)\n\t\t\tthis._parameter = this._curve.getParameterAt(this._point);\n\t\treturn this._parameter;\n\t},\n\n\tgetPoint: function() {\n\t\tif (!this._point && this._curve && this._parameter != null)\n\t\t\tthis._point = this._curve.getPoint(this._parameter);\n\t\treturn this._point;\n\t},\n\n\tgetTangent: function() {\n\t\tvar parameter = this.getParameter();\n\t\treturn parameter != null && this._curve\n\t\t\t\t&& this._curve.getTangent(parameter);\n\t},\n\n\tgetNormal: function() {\n\t\tvar parameter = this.getParameter();\n\t\treturn parameter != null && this._curve\n\t\t\t\t&& this._curve.getNormal(parameter);\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint();\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar parameter = this.getParameter();\n\t\tif (parameter != null)\n\t\t\tparts.push('parameter: ' + Base.formatNumber(parameter));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + Base.formatNumber(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t}\n});\n\nvar PathItem = this.PathItem = Item.extend({\n\n});\n\nvar Path = this.Path = PathItem.extend({\n\tinitialize: function(segments) {\n\t\tthis.base();\n\t\tthis._closed = false;\n\t\tthis._selectedSegmentState = 0;\n\t\tthis.setSegments(!segments || !Array.isArray(segments)\n\t\t\t\t|| typeof segments[0] !== 'object' ? arguments : segments);\n\t},\n\n\tclone: function() {\n\t\tvar copy = this._clone(new Path(this._segments));\n\t\tcopy._closed = this._closed;\n\t\tif (this._clockwise !== undefined)\n\t\t\tcopy._clockwise = this._clockwise;\n\t\treturn copy;\n\t},\n\n\t_changed: function(flags) {\n\t\tItem.prototype._changed.call(this, flags);\n\t\tif (flags & ChangeFlag.GEOMETRY) {\n\t\t\tdelete this._strokeBounds;\n\t\t\tdelete this._handleBounds;\n\t\t\tdelete this._roughBounds;\n\t\t\tdelete this._length;\n\t\t\tdelete this._clockwise;\n\t\t} else if (flags & ChangeFlag.STROKE) {\n\t\t\tdelete this._strokeBounds;\n\t\t}\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tif (!this._segments) {\n\t\t\tthis._segments = [];\n\t\t} else {\n\t\t\tthis._selectedSegmentState = 0;\n\t\t\tthis._segments.length = 0;\n\t\t\tif (this._curves)\n\t\t\t\tdelete this._curves;\n\t\t}\n\t\tthis._add(Segment.readAll(segments));\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tif (!this._curves) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tlength = segments.length;\n\t\t\tif (!this._closed && length > 0)\n\t\t\t\tlength--;\n\t\t\tthis._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tthis._curves[i] = Curve.create(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn this._curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tgetClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._segments.length,\n\t\t\t\t\ti;\n\t\t\t\tif (!closed && length > 0)\n\t\t\t\t\tlength--;\n\t\t\t\tthis._curves.length = length;\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[i = length - 1] = Curve.create(this,\n\t\t\t\t\t\tthis._segments[i], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(Change.GEOMETRY);\n\t\t}\n\t},\n\n\t_transform: function(matrix, flags) {\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar coords = new Array(6);\n\t\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\t\tthis._segments[i]._transformCoordinates(matrix, coords, true);\n\t\t\t}\n\t\t\tvar fillColor = this.getFillColor(),\n\t\t\t\tstrokeColor = this.getStrokeColor();\n\t\t\tif (fillColor && fillColor.transform)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor && strokeColor.transform)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index,\n\t\t\tfullySelected = this.isFullySelected();\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path) {\n\t\t\t\tsegment = segs[i] = new Segment(segment);\n\t\t\t}\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (fullySelected)\n\t\t\t\tsegment._selectionState = SelectionState.POINT;\n\t\t\tif (segment._selectionState)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selectionState);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._index = i;\n\t\t\t}\n\t\t}\n\t\tif (curves && --index >= 0) {\n\t\t\tcurves.splice(index, 0, Curve.create(this, segments[index],\n\t\t\t\tsegments[index + 1]));\n\t\t\tvar curve = curves[index + amount];\n\t\t\tif (curve) {\n\t\t\t\tcurve._segment1 = segments[index + amount];\n\t\t\t}\n\t\t}\n\t\tthis._changed(Change.GEOMETRY);\n\t\treturn segs;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readAll(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readAll(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function(segment) {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index, segment) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readAll(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readAll(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\tvar segments = this.removeSegments(index, index + 1);\n\t\treturn segments[0] || null;\n\t},\n\n\tremoveSegments: function(from, to) {\n\t\tfrom = from || 0;\n\t \tto = Base.pick(to, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tlast = to >= segments.length,\n\t\t\tremoved = segments.splice(from, to - from),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selectionState)\n\t\t\t\tthis._updateSelection(segment, segment._selectionState, 0);\n\t\t\tremoved._index = removed._path = undefined;\n\t\t}\n\t\tfor (var i = from, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tcurves.splice(from, amount);\n\t\t\tvar curve;\n\t\t\tif (curve = curves[from - 1])\n\t\t\t\tcurve._segment2 = segments[from];\n\t\t\tif (curve = curves[from])\n\t\t\t\tcurve._segment1 = segments[from];\n\t\t\tif (last && this._closed && (curve = curves[curves.length - 1]))\n\t\t\t\tcurve._segment2 = segments[0];\n\t\t}\n\t\tthis._changed(Change.GEOMETRY);\n\t\treturn removed;\n\t},\n\n\tisFullySelected: function() {\n\t\treturn this._selected && this._selectedSegmentState\n\t\t\t\t== this._segments.length * SelectionState.POINT;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar length = this._segments.length;\n\t\tthis._selectedSegmentState = selected\n\t\t\t\t? length * SelectionState.POINT : 0;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tthis._segments[i]._selectionState = selected\n\t\t\t\t\t? SelectionState.POINT : 0;\n\t\tthis.setSelected(selected);\n\t},\n\n\t_updateSelection: function(segment, oldState, newState) {\n\t\tsegment._selectionState = newState;\n\t\tvar total = this._selectedSegmentState += newState - oldState;\n\t\tif (total > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tflatten: function(maxDistance) {\n\t\tvar flattener = new PathFlattener(this),\n\t\t\tpos = 0,\n\t\t\tstep = flattener.length / Math.ceil(flattener.length / maxDistance),\n\t\t\tend = flattener.length + (this._closed ? -step : step) / 2;\n\t\tvar segments = [];\n\t\twhile (pos <= end) {\n\t\t\tsegments.push(new Segment(flattener.evaluate(pos, 0)));\n\t\t\tpos += step;\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tif (this._segments.length > 2) {\n\t\t\tvar fitter = new PathFitter(this, tolerance || 2.5);\n\t\t\tthis.setSegments(fitter.fit());\n\t\t}\n\t},\n\n\tisClockwise: function() {\n\t\tif (this._clockwise !== undefined)\n\t\t\treturn this._clockwise;\n\t\tvar sum = 0,\n\t\t\txPre, yPre;\n\t\tfunction edge(x, y) {\n\t\t\tif (xPre !== undefined)\n\t\t\t\tsum += (xPre - x) * (y + yPre);\n\t\t\txPre = x;\n\t\t\tyPre = y;\n\t\t}\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar seg1 = this._segments[i],\n\t\t\t\tseg2 = this._segments[i + 1 < l ? i + 1 : 0],\n\t\t\t\tpoint1 = seg1._point,\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tpoint2 = seg2._point;\n\t\t\tedge(point1._x, point1._y);\n\t\t\tedge(point1._x + handle1._x, point1._y + handle1._y);\n\t\t\tedge(point2._x + handle2._x, point2._y + handle2._y);\n\t\t\tedge(point2._x, point2._y);\n\t\t}\n\t\treturn sum > 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise)) {\n\t\t\tthis.reverse();\n\t\t\tthis._clockwise = clockwise;\n\t\t}\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t}\n\t\tif (this._clockwise !== undefined)\n\t\t\tthis._clockwise = !this._clockwise;\n\t},\n\n\tjoin: function(path) {\n\t\tif (path) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (last1._point.equals(last2._point))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1._point.equals(first2._point)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1._point.equals(first2._point))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1._point.equals(last2._point)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath.remove();\n\t\t\tvar first1 = this.getFirstSegment();\n\t\t\tlast1 = this.getLastSegment();\n\t\t\tif (last1._point.equals(first1._point)) {\n\t\t\t\tfirst1.setHandleIn(last1._handleIn);\n\t\t\t\tlast1.remove();\n\t\t\t\tthis.setClosed(true);\n\t\t\t}\n\t\t\tthis._changed(Change.GEOMETRY);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves();\n\t\t\tthis._length = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tthis._length += curves[i].getLength();\n\t\t}\n\t\treturn this._length;\n\t},\n\n\t_getOffset: function(location) {\n\t\tvar index = location && location.getIndex();\n\t\tif (index != null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\toffset = 0;\n\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\toffset += curves[i].getLength();\n\t\t\tvar curve = curves[index];\n\t\t\treturn offset + curve.getLength(0, location.getParameter());\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function(point) {\n\t\tvar curves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i];\n\t\t\tvar t = curve.getParameter(point);\n\t\t\tif (t != null)\n\t\t\t\treturn new CurveLocation(curve, t);\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocationAt: function(offset, isParameter) {\n\t\tvar curves = this.getCurves(),\n\t\t\tlength = 0;\n\t\tif (isParameter) {\n\t\t\tvar index = ~~offset; \n\t\t\treturn new CurveLocation(curves[index], offset - index);\n\t\t}\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar start = length,\n\t\t\t\tcurve = curves[i];\n\t\t\tlength += curve.getLength();\n\t\t\tif (length >= offset) {\n\t\t\t\treturn new CurveLocation(curve,\n\t\t\t\t\t\tcurve.getParameterAt(offset - start));\n\t\t\t}\n\t\t}\n\t\tif (offset <= this.getLength())\n\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\treturn null;\n\t},\n\n\tgetPointAt: function(offset, isParameter) {\n\t\tvar loc = this.getLocationAt(offset, isParameter);\n\t\treturn loc && loc.getPoint();\n\t},\n\n\tgetTangentAt: function(offset, isParameter) {\n\t\tvar loc = this.getLocationAt(offset, isParameter);\n\t\treturn loc && loc.getTangent();\n\t},\n\n\tgetNormalAt: function(offset, isParameter) {\n\t\tvar loc = this.getLocationAt(offset, isParameter);\n\t\treturn loc && loc.getNormal();\n\t},\n\n\tgetNearestLocation: function(point, matrix) {\n\t\tvar curves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point, matrix);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function(point, matrix) {\n\t\treturn this.getNearestLocation(point, matrix).getPoint();\n\t},\n\n\tcontains: function(point, matrix) {\n\t\tpoint = Point.read(arguments);\n\t\tif (!this._closed || !this.getRoughBounds(matrix)._containsPoint(point))\n\t\t\treturn false;\n\t\tvar curves = this.getCurves(),\n\t\t\tcrossings = 0,\n\t\t\troots = [];\n\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\tcrossings += curves[i].getCrossings(point, matrix, roots);\n\t\treturn (crossings & 1) == 1;\n\t},\n\n\t_hitTest: function(point, options, matrix) {\n\t\tvar tolerance = options.tolerance || 0,\n\t\t\tradius = (options.stroke ? this.getStrokeWidth() / 2 : 0) + tolerance,\n\t\t\tloc,\n\t\t\tres;\n\t\tvar coords = [],\n\t\t\tthat = this;\n\t\tfunction checkSegment(segment, ends) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = ends || options.segments ? 0 : 2,\n\t\t\t\t\tm = !ends && options.handles ? 6 : 2; j < m; j += 2) {\n\t\t\t\tif (point.getDistance(coords[j], coords[j + 1]) < tolerance)\n\t\t\t\t\treturn new HitResult(j == 0 ? 'segment'\n\t\t\t\t\t\t\t: 'handle-' + (j == 2 ? 'in' : 'out'),\n\t\t\t\t\t\t\tthat, { segment: segment });\n\t\t\t}\n\t\t}\n\t\tif (options.ends && !options.segments && !this._closed) {\n\t\t\tif (res = checkSegment(this.getFirstSegment(), true)\n\t\t\t\t\t|| checkSegment(this.getLastSegment(), true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\t\tif (res = checkSegment(this._segments[i]))\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\tif (options.stroke && radius > 0)\n\t\t\tloc = this.getNearestLocation(point, matrix);\n\t\tif (!(loc && loc._distance <= radius) && options.fill\n\t\t\t\t&& this.getFillColor() && this.contains(point, matrix))\n\t\t\treturn new HitResult('fill', this);\n\t\tif (!loc && options.stroke && radius > 0)\n\t\t\tloc = this.getNearestLocation(point, matrix);\n\t\tif (loc && loc._distance <= radius)\n\t\t\treturn options.stroke\n\t\t\t\t\t? new HitResult('stroke', this, { location: loc })\n\t\t\t\t\t: new HitResult('fill', this);\n\t}\n\n}, new function() { \n\n\tfunction drawHandles(ctx, segments) {\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tpoint = segment._point,\n\t\t\t\tstate = segment._selectionState,\n\t\t\t\tselected = state & SelectionState.POINT;\n\t\t\tif (selected || (state & SelectionState.HANDLE_IN))\n\t\t\t\tdrawHandle(ctx, point, segment._handleIn);\n\t\t\tif (selected || (state & SelectionState.HANDLE_OUT))\n\t\t\t\tdrawHandle(ctx, point, segment._handleOut);\n\t\t\tctx.save();\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(point._x - 2, point._y - 2, 4, 4);\n\t\t\tctx.fill();\n\t\t\tif (!selected) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.rect(point._x - 1, point._y - 1, 2, 2);\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n\n\tfunction drawHandle(ctx, point, handle) {\n\t\tif (!handle.isZero()) {\n\t\t\tvar handleX = point._x + handle._x,\n\t\t\t\thandleY = point._y + handle._y;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(point._x, point._y);\n\t\t\tctx.lineTo(handleX, handleY);\n\t\t\tctx.stroke();\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(handleX, handleY, 1.75, 0, Math.PI * 2, true);\n\t\t\tctx.fill();\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\thandleOut, outX, outY;\n\n\t\tfunction drawSegment(i) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tpoint = segment._point,\n\t\t\t\tx = point._x,\n\t\t\t\ty = point._y,\n\t\t\t\thandleIn = segment._handleIn;\n\t\t\tif (!handleOut) {\n\t\t\t\tctx.moveTo(x, y);\n\t\t\t} else {\n\t\t\t\tif (handleIn.isZero() && handleOut.isZero()) {\n\t\t\t\t\tctx.lineTo(x, y);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY,\n\t\t\t\t\t\t\thandleIn._x + x, handleIn._y + y, x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\thandleOut = segment._handleOut;\n\t\t\toutX = handleOut._x + x;\n\t\t\toutY = handleOut._y + y;\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(i);\n\t\tif (path._closed && length > 1)\n\t\t\tdrawSegment(0);\n\t}\n\n\tfunction drawDashes(ctx, path, dashArray, dashOffset) {\n\t\tvar flattener = new PathFlattener(path),\n\t\t\tfrom = dashOffset, to,\n\t\t\ti = 0;\n\t\twhile (from < flattener.length) {\n\t\t\tto = from + dashArray[(i++) % dashArray.length];\n\t\t\tflattener.drawPart(ctx, from, to);\n\t\t\tfrom = to + dashArray[(i++) % dashArray.length];\n\t\t}\n\t}\n\n\treturn {\n\t\tdraw: function(ctx, param) {\n\t\t\tif (!param.compound)\n\t\t\t\tctx.beginPath();\n\n\t\t\tvar fillColor = this.getFillColor(),\n\t\t\t\tstrokeColor = this.getStrokeColor(),\n\t\t\t\tdashArray = this.getDashArray() || [], \n\t\t\t\thasDash = !!dashArray.length;\n\n\t\t\tif (param.compound || param.selection || this._clipMask || fillColor\n\t\t\t\t\t|| strokeColor && !hasDash) {\n\t\t\t\tdrawSegments(ctx, this);\n\t\t\t}\n\n\t\t\tif (param.selection) {\n\t\t\t\tctx.stroke();\n\t\t\t\tdrawHandles(ctx, this._segments);\n\t\t\t} else if (this._clipMask) {\n\t\t\t\tctx.clip();\n\t\t\t} else if (!param.compound && (fillColor || strokeColor)) {\n\t\t\t\tctx.save();\n\t\t\t\tthis._setStyles(ctx);\n\t\t\t\tif (!fillColor || !strokeColor)\n\t\t\t\t\tctx.globalAlpha = this._opacity;\n\t\t\t\tif (fillColor) {\n\t\t\t\t\tctx.fillStyle = fillColor.getCanvasStyle(ctx);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t\tif (strokeColor) {\n\t\t\t\t\tctx.strokeStyle = strokeColor.getCanvasStyle(ctx);\n\t\t\t\t\tif (hasDash) {\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tdrawDashes(ctx, this, dashArray, this.getDashOffset());\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\t};\n}, new function() { \n\n\tfunction getFirstControlPoints(rhs) {\n\t\tvar n = rhs.length,\n\t\t\tx = [], \n\t\t\ttmp = [], \n\t\t\tb = 2;\n\t\tx[0] = rhs[0] / b;\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\ttmp[i] = 1 / b;\n\t\t\tb = (i < n - 1 ? 4 : 2) - tmp[i];\n\t\t\tx[i] = (rhs[i] - x[i - 1]) / b;\n\t\t}\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tx[n - i - 1] -= tmp[n - i] * x[n - i];\n\t\t}\n\t\treturn x;\n\t};\n\n\tvar styles = {\n\t\tgetStrokeWidth: 'lineWidth',\n\t\tgetStrokeJoin: 'lineJoin',\n\t\tgetStrokeCap: 'lineCap',\n\t\tgetMiterLimit: 'miterLimit'\n\t};\n\n\treturn {\n\t\t_setStyles: function(ctx) {\n\t\t\tfor (var i in styles) {\n\t\t\t\tvar style = this._style[i]();\n\t\t\t\tif (style)\n\t\t\t\t\tctx[styles[i]] = style;\n\t\t\t}\n\t\t},\n\n\t\tsmooth: function() {\n\t\t\tvar segments = this._segments,\n\t\t\t\tsize = segments.length,\n\t\t\t\tn = size,\n\t\t\t\toverlap;\n\n\t\t\tif (size <= 2)\n\t\t\t\treturn;\n\n\t\t\tif (this._closed) {\n\t\t\t\toverlap = Math.min(size, 4);\n\t\t\t\tn += Math.min(size, overlap) * 2;\n\t\t\t} else {\n\t\t\t\toverlap = 0;\n\t\t\t}\n\t\t\tvar knots = [];\n\t\t\tfor (var i = 0; i < size; i++)\n\t\t\t\tknots[i + overlap] = segments[i]._point;\n\t\t\tif (this._closed) {\n\t\t\t\tfor (var i = 0; i < overlap; i++) {\n\t\t\t\t\tknots[i] = segments[i + size - overlap]._point;\n\t\t\t\t\tknots[i + size + overlap] = segments[i]._point;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tvar rhs = [];\n\n\t\t\tfor (var i = 1; i < n - 1; i++)\n\t\t\t\trhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;\n\t\t\trhs[0] = knots[0]._x + 2 * knots[1]._x;\n\t\t\trhs[n - 1] = 3 * knots[n - 1]._x;\n\t\t\tvar x = getFirstControlPoints(rhs);\n\n\t\t\tfor (var i = 1; i < n - 1; i++)\n\t\t\t\trhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;\n\t\t\trhs[0] = knots[0]._y + 2 * knots[1]._y;\n\t\t\trhs[n - 1] = 3 * knots[n - 1]._y;\n\t\t\tvar y = getFirstControlPoints(rhs);\n\n\t\t\tif (this._closed) {\n\t\t\t\tfor (var i = 0, j = size; i < overlap; i++, j++) {\n\t\t\t\t\tvar f1 = (i / overlap);\n\t\t\t\t\tvar f2 = 1 - f1;\n\t\t\t\t\tx[j] = x[i] * f1 + x[j] * f2;\n\t\t\t\t\ty[j] = y[i] * f1 + y[j] * f2;\n\t\t\t\t\tvar ie = i + overlap, je = j + overlap;\n\t\t\t\t\tx[je] = x[ie] * f2 + x[je] * f1;\n\t\t\t\t\ty[je] = y[ie] * f2 + y[je] * f1;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tvar handleIn = null;\n\t\t\tfor (var i = overlap; i <= n - overlap; i++) {\n\t\t\t\tvar segment = segments[i - overlap];\n\t\t\t\tif (handleIn)\n\t\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\n\t\t\t\tif (i < n) {\n\t\t\t\t\tsegment.setHandleOut(\n\t\t\t\t\t\t\tnew Point(x[i], y[i]).subtract(segment._point));\n\t\t\t\t\tif (i < n - 1)\n\t\t\t\t\t\thandleIn = new Point(\n\t\t\t\t\t\t\t\t2 * knots[i + 1]._x - x[i + 1],\n\t\t\t\t\t\t\t\t2 * knots[i + 1]._y - y[i + 1]);\n\t\t\t\t\telse\n\t\t\t\t\t\thandleIn = new Point(\n\t\t\t\t\t\t\t\t(knots[n]._x + x[n - 1]) / 2,\n\t\t\t\t\t\t\t\t(knots[n]._y + y[n - 1]) / 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._closed && handleIn) {\n\t\t\t\tvar segment = this._segments[0];\n\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\n\t\t\t}\n\t\t}\n\t};\n}, new function() { \n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (segments.length == 0)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function(point) {\n\t\t\tif (!this._segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function(point) {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function(point) {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function(handle1, handle2, to) {\n\t\t\thandle1 = Point.read(arguments, 0, 1);\n\t\t\thandle2 = Point.read(arguments, 1, 1);\n\t\t\tto = Point.read(arguments, 2, 1);\n\t\t\tvar current = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function(handle, to) {\n\t\t\thandle = Point.read(arguments, 0, 1);\n\t\t\tto = Point.read(arguments, 1, 1);\n\t\t\tvar current = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1/3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1/3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function(through, to, parameter) {\n\t\t\tthrough = Point.read(arguments, 0, 1);\n\t\t\tto = Point.read(arguments, 1, 1);\n\t\t\tvar t = Base.pick(parameter, 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function(to, clockwise ) {\n\t\t\tvar current = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tthrough;\n\t\t\tif (clockwise === undefined)\n\t\t\t\tclockwise = true;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tto = Point.read(arguments, 0, 1);\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else {\n\t\t\t\tthrough = Point.read(arguments, 0, 1);\n\t\t\t\tto = Point.read(arguments, 1, 1);\n\t\t\t}\n\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\tthrough.subtract(from).rotate(90)),\n\t\t\t \tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\tto.subtract(through).rotate(90)),\n\t\t\t\tcenter = l1.intersect(l2),\n\t\t\t\tline = new Line(from, to, true),\n\t\t\t\tthroughSide = line.getSide(through);\n\t\t\tif (!center) {\n\t\t\t\tif (!throughSide)\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tthrow new Error(\"Cannot put an arc through the given points: \"\n\t\t\t\t\t+ [from, through, to]);\n\t\t\t}\n\t\t\tvar vector = from.subtract(center),\n\t\t\t\tradius = vector.getLength(),\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center)),\n\t\t\t\tcenterSide = line.getSide(center);\n\t\t\tif (centerSide == 0) {\n\t\t\t\textent = throughSide * Math.abs(extent);\n\t\t\t} else if (throughSide == centerSide) {\n\t\t\t\textent -= 360 * (extent < 0 ? -1 : 1);\n\t\t\t}\n\t\t\tvar ext = Math.abs(extent),\n\t\t\t\tcount =  ext >= 360 ? 4 : Math.ceil(ext / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = i < count ? center.add(vector) : to;\n\t\t\t\tvar out = i < count ? vector.rotate(90).multiply(z) : null;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tsegments.push(\n\t\t\t\t\t\tnew Segment(pt, vector.rotate(-90).multiply(z), out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function(vector) {\n\t\t\tvector = Point.read(arguments);\n\t\t\tvar current = getCurrentSegment(this);\n\t\t\tthis.lineTo(current._point.add(vector));\n\t\t},\n\n\t\tcurveBy: function(throughVector, toVector, parameter) {\n\t\t\tthroughVector = Point.read(throughVector);\n\t\t\ttoVector = Point.read(toVector);\n\t\t\tvar current = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(throughVector), current.add(toVector),\n\t\t\t\t\tparameter);\n\t\t},\n\n\t\tarcBy: function(throughVector, toVector) {\n\t\t\tthroughVector = Point.read(throughVector);\n\t\t\ttoVector = Point.read(toVector);\n\t\t\tvar current = getCurrentSegment(this)._point;\n\t\t\tthis.arcBy(current.add(throughVector), current.add(toVector));\n\t\t},\n\n\t\tclosePath: function() {\n\t\t\tthis.setClosed(true);\n\t\t}\n\t};\n}, new function() { \n\n\tfunction getBounds(that, matrix, strokePadding) {\n\t\tvar segments = that._segments,\n\t\t\tfirst = segments[0];\n\t\tif (!first)\n\t\t\treturn null;\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = new Array(6);\n\t\tif (matrix && matrix.isIdentity())\n\t\t\tmatrix = null;\n\t\tfirst._transformCoordinates(matrix, prevCoords, false);\n\t\tvar min = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(0), \n\t\t\ttMin = Numerical.TOLERANCE,\n\t\t\ttMax = 1 - tMin;\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar v0 = prevCoords[i], \n\t\t\t\t\tv1 = prevCoords[i + 4], \n\t\t\t\t\tv2 = coords[i + 2], \n\t\t\t\t\tv3 = coords[i]; \n\n\t\t\t\tfunction add(value, t) {\n\t\t\t\t\tvar padding = 0;\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tvar u = 1 - t;\n\t\t\t\t\t\tvalue = u * u * u * v0\n\t\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t\t+ t * t * t * v3;\n\t\t\t\t\t\tpadding = strokePadding ? strokePadding[i] : 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar left = value - padding,\n\t\t\t\t\t\tright = value + padding;\n\t\t\t\t\tif (left < min[i])\n\t\t\t\t\t\tmin[i] = left;\n\t\t\t\t\tif (right > max[i])\n\t\t\t\t\t\tmax[i] = right;\n\n\t\t\t\t}\n\t\t\t\tadd(v3, null);\n\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0;\n\n\t\t\t\tif (a == 0) {\n\t\t\t\t\tif (b == 0)\n\t\t\t\t\t    continue;\n\t\t\t\t\tvar t = -c / b;\n\t\t\t\t\tif (tMin < t && t < tMax)\n\t\t\t\t\t\tadd(null, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar q = b * b - 4 * a * c;\n\t\t\t\tif (q < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar sqrt = Math.sqrt(q),\n\t\t\t\t\tf = -0.5 / a,\n\t\t\t\t \tt1 = (b - sqrt) * f,\n\t\t\t\t\tt2 = (b + sqrt) * f;\n\t\t\t\tif (tMin < t1 && t1 < tMax)\n\t\t\t\t\tadd(null, t1);\n\t\t\t\tif (tMin < t2 && t2 < tMax)\n\t\t\t\t\tadd(null, t2);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (that._closed)\n\t\t\tprocessSegment(first);\n\t\treturn Rectangle.create(min[0], min[1],\n\t\t\t\t\tmax[0] - min[0], max[1] - min[1]);\n\t}\n\n\tfunction getPenPadding(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar mx = matrix.createShiftless(),\n\t\t\thor = mx.transform(new Point(radius, 0)),\n\t\t\tver = mx.transform(new Point(0, radius)),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar tx = - Math.atan(b * Math.tan(phi)),\n\t\t\tty = + Math.atan(b / Math.tan(phi)),\n\t\t\tx = a * Math.cos(tx) * Math.cos(phi)\n\t\t\t\t- b * Math.sin(tx) * Math.sin(phi),\n\t\t\ty = b * Math.sin(ty) * Math.cos(phi)\n\t\t\t\t+ a * Math.cos(ty) * Math.sin(phi);\n\t\treturn [Math.abs(x), Math.abs(y)];\n\t}\n\n\treturn {\n\t\tgetBounds: function() {\n\t\t\tvar useCache = arguments[0] === undefined;\n\t\t\tif (useCache && this._bounds)\n\t\t\t\treturn this._bounds;\n\t\t\tvar bounds = this._createBounds(getBounds(this, arguments[0]));\n\t\t\tif (useCache)\n\t\t\t\tthis._bounds = bounds;\n\t\t\treturn bounds;\n\t\t},\n\n\t\tgetStrokeBounds: function() {\n\t\t\tif (!this._style._strokeColor || !this._style._strokeWidth)\n\t\t\t\treturn this.getBounds.apply(this, arguments);\n\t\t\tvar useCache = arguments[0] === undefined;\n\t\t\tif (useCache && this._strokeBounds)\n\t\t\t\treturn this._strokeBounds;\n\t\t\tvar matrix = arguments[0], \n\t\t\t\twidth = this.getStrokeWidth(),\n\t\t\t\tradius = width / 2,\n\t\t\t\tpadding = getPenPadding(radius, matrix),\n\t\t\t\tjoin = this.getStrokeJoin(),\n\t\t\t\tcap = this.getStrokeCap(),\n\t\t\t\tmiter = this.getMiterLimit() * width / 2,\n\t\t\t\tsegments = this._segments,\n\t\t\t\tlength = segments.length,\n\t\t\t\tbounds = getBounds(this, matrix, getPenPadding(radius));\n\t\t\tvar joinBounds = new Rectangle(new Size(padding).multiply(2));\n\n\t\t\tfunction add(point) {\n\t\t\t\tbounds = bounds.include(matrix\n\t\t\t\t\t? matrix.transform(point) : point);\n\t\t\t}\n\n\t\t\tfunction addBevelJoin(curve, t) {\n\t\t\t\tvar point = curve.getPoint(t),\n\t\t\t\t\tnormal = curve.getNormal(t).normalize(radius);\n\t\t\t\tadd(point.add(normal));\n\t\t\t\tadd(point.subtract(normal));\n\t\t\t}\n\n\t\t\tfunction addJoin(segment, join) {\n\t\t\t\tif (join === 'round' || !segment._handleIn.isZero()\n\t\t\t\t\t\t&& !segment._handleOut.isZero()) {\n\t\t\t\t\tbounds = bounds.unite(joinBounds.setCenter(matrix\n\t\t\t\t\t\t? matrix.transform(segment._point) : segment._point));\n\t\t\t\t} else if (join == 'bevel') {\n\t\t\t\t\tvar curve = segment.getCurve();\n\t\t\t\t\taddBevelJoin(curve, 0);\n\t\t\t\t\taddBevelJoin(curve.getPrevious(), 1);\n\t\t\t\t} else if (join == 'miter') {\n\t\t\t\t\tvar curve2 = segment.getCurve(),\n\t\t\t\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\t\t\t\tpoint = curve2.getPoint(0),\n\t\t\t\t\t\tnormal1 = curve1.getNormal(1).normalize(radius),\n\t\t\t\t\t\tnormal2 = curve2.getNormal(0).normalize(radius),\n\t\t\t\t\t\tline1 = new Line(point.subtract(normal1),\n\t\t\t\t\t\t\t\tnew Point(-normal1.y, normal1.x)),\n\t\t\t\t\t\tline2 = new Line(point.subtract(normal2),\n\t\t\t\t\t\t\t\tnew Point(-normal2.y, normal2.x)),\n\t\t\t\t\t\tcorner = line1.intersect(line2);\n\t\t\t\t\tif (!corner || point.getDistance(corner) > miter) {\n\t\t\t\t\t\taddJoin(segment, 'bevel');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd(corner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction addCap(segment, cap, t) {\n\t\t\t\tswitch (cap) {\n\t\t\t\tcase 'round':\n\t\t\t\t\treturn addJoin(segment, cap);\n\t\t\t\tcase 'butt':\n\t\t\t\tcase 'square':\n\t\t\t\t\tvar curve = segment.getCurve(),\n\t\t\t\t\t\tpoint = curve.getPoint(t),\n\t\t\t\t\t\tnormal = curve.getNormal(t).normalize(radius);\n\t\t\t\t\tif (cap === 'square')\n\t\t\t\t\t\tpoint = point.add(normal.y, -normal.x);\n\t\t\t\t\tadd(point.add(normal));\n\t\t\t\t\tadd(point.subtract(normal));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 1, l = length - (this._closed ? 0 : 1); i < l; i++) {\n\t\t\t\taddJoin(segments[i], join);\n\t\t\t}\n\t\t\tif (this._closed) {\n\t\t\t\taddJoin(segments[0], join);\n\t\t\t} else {\n\t\t\t\taddCap(segments[0], cap, 0);\n\t\t\t\taddCap(segments[length - 1], cap, 1);\n\t\t\t}\n\t\t\tif (useCache)\n\t\t\t\tthis._strokeBounds = bounds;\n\t\t\treturn bounds;\n\t\t},\n\n\t\tgetHandleBounds: function() {\n\t\t\tvar matrix = arguments[0],\n\t\t\t\tuseCache = matrix === undefined;\n\t\t\tif (useCache && this._handleBounds)\n\t\t\t\treturn this._handleBounds;\n\t\t\tvar coords = new Array(6),\n\t\t\t\tstroke = arguments[1] / 2 || 0, \n\t\t\t\tjoin = arguments[2] / 2 || 0, \n\t\t\t\topen = !this._closed,\n\t\t\t\tx1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2;\n\t\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\t\tvar segment = this._segments[i];\n\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\t\tvar padding = j == 0 ? join : stroke,\n\t\t\t\t\t\tx = coords[j],\n\t\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\t\txn = x - padding,\n\t\t\t\t\t\txx = x + padding,\n\t\t\t\t\t\tyn = y - padding,\n\t\t\t\t\t\tyx = y + padding;\n\t\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar bounds = Rectangle.create(x1, y1, x2 - x1, y2 - y1);\n\t\t\tif (useCache)\n\t\t\t\tthis._handleBounds = bounds;\n\t\t\treturn bounds;\n\t\t},\n\n\t\tgetRoughBounds: function() {\n\t\t\tvar useCache = arguments[0] === undefined;\n\t\t\tif (useCache && this._roughBounds)\n\t\t\t\treturn this._roughBounds;\n\t\t\tvar bounds = this.getHandleBounds(arguments[0], this.strokeWidth,\n\t\t\t\t\tthis.getStrokeJoin() == 'miter'\n\t\t\t\t\t\t? this.strokeWidth * this.getMiterLimit()\n\t\t\t\t\t\t: this.strokeWidth);\n\t\t\tif (useCache)\n\t\t\t\tthis._roughBounds = bounds;\n\t\t\treturn bounds;\n\t\t}\n\t};\n});\n\nPath.inject({ statics: new function() {\n\tvar kappa = 2 / 3 * (Math.sqrt(2) - 1);\n\n\tvar ovalSegments = [\n\t\tnew Segment([0, 0.5], [0, kappa ], [0, -kappa]),\n\t\tnew Segment([0.5, 0], [-kappa, 0], [kappa, 0 ]),\n\t\tnew Segment([1, 0.5], [0, -kappa], [0, kappa ]),\n\t\tnew Segment([0.5, 1], [kappa, 0 ], [-kappa, 0])\n\t];\n\n\treturn {\n\t\tLine: function() {\n\t\t\tvar step = Math.floor(arguments.length / 2);\n\t\t\treturn new Path(\n\t\t\t\tSegment.read(arguments, 0, step),\n\t\t\t\tSegment.read(arguments, step, step)\n\t\t\t);\n\t\t},\n\n\t\tRectangle: function(rect) {\n\t\t\trect = Rectangle.read(arguments);\n\t\t\tvar left = rect.x,\n\t\t\t\ttop = rect.y\n\t\t\t\tright = left + rect.width,\n\t\t\t\tbottom = top + rect.height,\n\t\t\t\tpath = new Path();\n\t\t\tpath._add([\n\t\t\t\tnew Segment(Point.create(left, bottom)),\n\t\t\t\tnew Segment(Point.create(left, top)),\n\t\t\t\tnew Segment(Point.create(right, top)),\n\t\t\t\tnew Segment(Point.create(right, bottom))\n\t\t\t]);\n\t\t\tpath._closed = true;\n\t\t\treturn path;\n\t\t},\n\n\t\tRoundRectangle: function(rect, size) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\trect = Rectangle.read(arguments, 0, 1);\n\t\t\t\tsize = Size.read(arguments, 1, 1);\n\t\t\t} else if (arguments.length == 6) {\n\t\t\t\trect = Rectangle.read(arguments, 0, 4);\n\t\t\t\tsize = Size.read(arguments, 4, 2);\n\t\t\t}\n\t\t\tsize = Size.min(size, rect.getSize(true).divide(2));\n\t\t\tvar path = new Path(),\n\t\t\t\tuSize = size.multiply(kappa * 2),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true);\n\t\t\tpath._add([\n\t\t\t\tnew Segment(bl.add(size.width, 0), null, [-uSize.width, 0]),\n\t\t\t\tnew Segment(bl.subtract(0, size.height), [0, uSize.height], null),\n\n\t\t\t\tnew Segment(tl.add(0, size.height), null, [0, -uSize.height]),\n\t\t\t\tnew Segment(tl.add(size.width, 0), [-uSize.width, 0], null),\n\n\t\t\t\tnew Segment(tr.subtract(size.width, 0), null, [uSize.width, 0]),\n\t\t\t\tnew Segment(tr.add(0, size.height), [0, -uSize.height], null),\n\n\t\t\t\tnew Segment(br.subtract(0, size.height), null, [0, uSize.height]),\n\t\t\t\tnew Segment(br.subtract(size.width, 0), [uSize.width, 0], null)\n\t\t\t]);\n\t\t\tpath._closed = true;\n\t\t\treturn path;\n\t\t},\n\n\t\tOval: function(rect) {\n\t\t\trect = Rectangle.read(arguments);\n\t\t\tvar path = new Path(),\n\t\t\t\tpoint = rect.getPoint(true),\n\t\t\t\tsize = rect.getSize(true),\n\t\t\t\tsegments = new Array(4);\n\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\tvar segment = ovalSegments[i];\n\t\t\t\tsegments[i] = new Segment(\n\t\t\t\t\tsegment._point.multiply(size).add(point),\n\t\t\t\t\tsegment._handleIn.multiply(size),\n\t\t\t\t\tsegment._handleOut.multiply(size)\n\t\t\t\t);\n\t\t\t}\n\t\t\tpath._add(segments);\n\t\t\tpath._closed = true;\n\t\t\treturn path;\n\t\t},\n\n\t\tCircle: function(center, radius) {\n\t\t\tif (arguments.length == 3) {\n\t\t\t\tcenter = Point.read(arguments, 0, 2);\n\t\t\t\tradius = arguments[2];\n\t\t\t} else {\n\t\t\t\tcenter = Point.read(arguments, 0, 1);\n\t\t\t}\n\t\t\treturn Path.Oval(new Rectangle(center.subtract(radius),\n\t\t\t\t\tSize.create(radius * 2, radius * 2)));\n\t\t},\n\n\t\tArc: function(from, through, to) {\n\t\t\tvar path = new Path();\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path;\n\t\t},\n\n\t\tRegularPolygon: function(center, numSides, radius) {\n\t\t\tcenter = Point.read(arguments, 0, 1);\n\t\t\tvar path = new Path(),\n\t\t\t\tstep = 360 / numSides,\n\t\t\t\tthree = !(numSides % 3),\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(numSides);\n\t\t\tfor (var i = 0; i < numSides; i++) {\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\t}\n\t\t\tpath._add(segments);\n\t\t\tpath._closed = true;\n\t\t\treturn path;\n\t\t},\n\n\t\tStar: function(center, numPoints, radius1, radius2) {\n\t\t\tcenter = Point.read(arguments, 0, 1);\n\t\t\tnumPoints *= 2;\n\t\t\tvar path = new Path(),\n\t\t\t\tstep = 360 / numPoints,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(numPoints);\n\t\t\tfor (var i = 0; i < numPoints; i++) {\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));\n\t\t\t}\n\t\t\tpath._add(segments);\n\t\t\tpath._closed = true;\n\t\t\treturn path;\n\t\t}\n\t};\n}});\n\nvar CompoundPath = this.CompoundPath = PathItem.extend({\n\tinitialize: function(paths) {\n\t\tthis.base();\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tvar items = !paths || !Array.isArray(paths)\n\t\t\t\t|| typeof paths[0] !== 'object' ? arguments : paths;\n\t\tthis.addChildren(items);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tthis.base(index, item);\n\t\tif (item._clockwise === undefined)\n\t\t\titem.setClockwise(item._index == 0);\n\t},\n\n\tsimplify: function() {\n\t\tif (this._children.length == 1) {\n\t\t\tvar child = this._children[0];\n\t\t\tchild.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\tsmooth: function() {\n\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\tthis._children[i].smooth();\n\t},\n\n\tdraw: function(ctx, param) {\n\t\tvar l = this._children.length;\n\t\tif (l == 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar firstChild = this._children[0];\n\t\tctx.beginPath();\n\t\tparam.compound = true;\n\t\tfor (var i = 0; i < l; i++)\n\t\t\tItem.draw(this._children[i], ctx, param);\n\t\tfirstChild._setStyles(ctx);\n\t\tvar fillColor = firstChild.getFillColor(),\n\t\t\tstrokeColor = firstChild.getStrokeColor();\n\t\tif (fillColor) {\n\t\t\tctx.fillStyle = fillColor.getCanvasStyle(ctx);\n\t\t\tctx.fill();\n\t\t}\n\t\tif (strokeColor) {\n\t\t\tctx.strokeStyle = strokeColor.getCanvasStyle(ctx);\n\t\t\tctx.stroke();\n\t\t}\n\t\tparam.compound = false;\n\t}\n}, new function() { \n\tfunction getCurrentPath(that) {\n\t\tif (!that._children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn that._children[that._children.length - 1];\n\t}\n\n\tvar fields = {\n\t\tmoveTo: function(point) {\n\t\t\tvar path = new Path();\n\t\t\tthis.addChild(path);\n\t\t\tpath.moveTo.apply(path, arguments);\n\t\t},\n\n\t\tmoveBy: function(point) {\n\t\t\tthis.moveTo(getCurrentPath(this).getLastSegment()._point.add(\n\t\t\t\t\tPoint.read(arguments)));\n\t\t},\n\n\t\tclosePath: function() {\n\t\t\tgetCurrentPath(this).setClosed(true);\n\t\t}\n\t};\n\n\tBase.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'curveBy', 'arcBy'], function(key) {\n\t\tfields[key] = function() {\n\t\t\tvar path = getCurrentPath(this);\n\t\t\tpath[key].apply(path, arguments);\n\t\t};\n\t});\n\n\treturn fields;\n});\n\nvar PathFlattener = Base.extend({\n\tinitialize: function(path) {\n\t\tthis.curves = []; \n\t\tthis.parts = []; \n\t\tthis.length = 0; \n\t\tthis.index = 0;\n\n\t\tvar segments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2,\n\t\t\tthat = this;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2);\n\t\t\tthat.curves.push(curve);\n\t\t\tthat._computeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\t},\n\n\t_computeParts: function(curve, index, minT, maxT) {\n\t\tif ((maxT - minT) > 1 / 32 && !Curve.isFlatEnough(curve)) {\n\t\t\tvar curves = Curve.subdivide(curve);\n\t\t\tvar halfT = (minT + maxT) / 2;\n\t\t\tthis._computeParts(curves[0], index, minT, halfT);\n\t\t\tthis._computeParts(curves[1], index, halfT, maxT);\n\t\t} else {\n\t\t\tvar x = curve[6] - curve[0],\n\t\t\t\ty = curve[7] - curve[1],\n\t\t\t\tdist = Math.sqrt(x * x + y * y);\n\t\t\tif (dist > Numerical.TOLERANCE) {\n\t\t\t\tthis.length += dist;\n\t\t\t\tthis.parts.push({\n\t\t\t\t\toffset: this.length,\n\t\t\t\t\tvalue: maxT,\n\t\t\t\t\tindex: index\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\n\tgetParameterAt: function(offset) {\n\t\tvar i, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (j == 0 || this.parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (var l = this.parts.length; i < l; i++) {\n\t\t\tvar part = this.parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = this.parts[i - 1];\n\t\t\t\tvar prevVal = prev && prev.index == part.index ? prev.value : 0,\n\t\t\t\t\tprevLen = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tvalue: prevVal + (part.value - prevVal)\n\t\t\t\t\t\t* (offset - prevLen) /  (part.offset - prevLen),\n\t\t\t\t\tindex: part.index\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tvar part = this.parts[this.parts.length - 1];\n\t\treturn {\n\t\t\tvalue: 1,\n\t\t\tindex: part.index\n\t\t};\n\t},\n\n\tevaluate: function(offset, type) {\n\t\tvar param = this.getParameterAt(offset);\n\t\treturn Curve.evaluate(this.curves[param.index], param.value, type);\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tfrom = this.getParameterAt(from);\n\t\tto = this.getParameterAt(to);\n\t\tfor (var i = from.index; i <= to.index; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti == from.index ? from.value : 0,\n\t\t\t\t\ti == to.index ? to.value : 1);\n\t\t\tif (i == from.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n});\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path, error) {\n\t\tthis.points = [];\n\t\tvar segments = path._segments,\n\t\t\tprev;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point.clone();\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tthis.points.push(point);\n\t\t\t\tprev = point;\n\t\t\t}\n\t\t}\n\t\tthis.error = error;\n\t},\n\n\tfit: function() {\n\t\tthis.segments = [new Segment(this.points[0])];\n\t\tthis.fitCubic(0, this.points.length - 1,\n\t\t\t\tthis.points[1].subtract(this.points[0]).normalize(),\n\t\t\t\tthis.points[this.points.length - 2].subtract(\n\t\t\t\t\tthis.points[this.points.length - 1]).normalize());\n\t\treturn this.segments;\n\t},\n\n\tfitCubic: function(first, last, tan1, tan2) {\n\t\tif (last - first == 1) {\n\t\t\tvar pt1 = this.points[first],\n\t\t\t\tpt2 = this.points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve([pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(this.error, this.error * this.error),\n\t\t\terror,\n\t\t\tsplit;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < this.error) {\n\t\t\t\tthis.addCurve(curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tthis.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar V1 = this.points[split - 1].subtract(this.points[split]),\n\t\t\tV2 = this.points[split].subtract(this.points[split + 1]),\n\t\t\ttanCenter = V1.add(V2).divide(2).normalize();\n\t\tthis.fitCubic(first, split, tan1, tanCenter);\n\t\tthis.fitCubic(split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(curve) {\n\t\tvar prev = this.segments[this.segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tthis.segments.push(\n\t\t\t\tnew Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = Numerical.EPSILON,\n\t\t\tpt1 = this.points[first],\n\t\t\tpt2 = this.points[last],\n\t\t \tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = this.points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1, alpha2;\n\t\tif (Math.abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X  = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1  = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\tif (Math.abs(c0) > epsilon) {\n\t\t\t\talpha1 = alpha2 = X[0] / c0;\n\t\t\t} else if (Math.abs(c0) > epsilon) {\n\t\t\t\talpha1 = alpha2 = X[1] / c1;\n\t\t\t} else {\n\t\t\t\talpha1 = alpha2 = 0.;\n\t\t\t}\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1);\n\t\tepsilon *= segLength;\n\t\tif (alpha1 < epsilon || alpha2 < epsilon) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t}\n\n\t\treturn [pt1, pt1.add(tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(tan2.normalize(alpha2)), pt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t \tpt1 = this.evaluate(2, curve1, u),\n\t\t \tpt2 = this.evaluate(1, curve2, u),\n\t\t \tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\tif (Math.abs(df) < Numerical.TOLERANCE)\n\t\t\treturn u;\n\t\treturn u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y; \n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = this.TextItem = Item.extend({\n\tinitialize: function() {\n\t\tthis.base();\n\t\tthis._content = '';\n\t\tthis._characterStyle = CharacterStyle.create(this);\n\t\tthis.setCharacterStyle(this._project.getCurrentStyle());\n\t\tthis._paragraphStyle = ParagraphStyle.create(this);\n\t\tthis.setParagraphStyle();\n\t},\n\n\t_clone: function(copy) {\n\t\tcopy._content = this._content;\n\t\tcopy.setCharacterStyle(this._characterStyle);\n\t\tcopy.setParagraphStyle(this._paragraphStyle);\n\t\treturn this.base(copy);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._changed(Change.CONTENT);\n\t\tthis._content = '' + content;\n\t},\n\n\tgetCharacterStyle: function() {\n\t\treturn this._characterStyle;\n\t},\n\n\tsetCharacterStyle: function(style) {\n\t\tthis._characterStyle.initialize(style);\n\t},\n\n\tgetParagraphStyle: function() {\n\t\treturn this._paragraphStyle;\n\t},\n\n\tsetParagraphStyle: function(style) {\n\t\tthis._paragraphStyle.initialize(style);\n\t}\n});\n\nvar PointText = this.PointText = TextItem.extend({\n\tinitialize: function(point) {\n\t\tthis.base();\n\t\tthis._point = Point.read(arguments).clone();\n\t\tthis._matrix = new Matrix().translate(this._point);\n\t},\n\n\tclone: function() {\n\t\tvar copy = this._clone(new PointText(this._point));\n\t\tcopy._matrix.initialize(this._matrix);\n\t\treturn copy;\n\t},\n\n\tgetPoint: function() {\n\t\treturn LinkedPoint.create(this, 'setPoint',\n\t\t\t\tthis._point.x, this._point.y);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis.translate(Point.read(arguments).subtract(this._point));\n\t},\n\n\tgetPosition: function() {\n\t\treturn this.getPoint();\n\t},\n\n\tsetPosition: function(point) {\n\t\tthis.setPoint.apply(this, arguments);\n\t},\n\n\t_transform: function(matrix, flags) {\n\t\tthis._matrix.preConcatenate(matrix);\n\t\tmatrix._transformPoint(this._point, this._point);\n\t},\n\n\tdraw: function(ctx) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tctx.save();\n\t\tctx.font = this.getFontSize() + 'pt ' + this.getFont();\n\t\tctx.textAlign = this.getJustification();\n\t\tthis._matrix.applyToContext(ctx);\n\n\t\tvar fillColor = this.getFillColor();\n\t\tvar strokeColor = this.getStrokeColor();\n\t\tif (!fillColor || !strokeColor)\n\t\t\tctx.globalAlpha = this._opacity;\n\t\tif (fillColor) {\n\t\t\tctx.fillStyle = fillColor.getCanvasStyle(ctx);\n\t\t\tctx.fillText(this._content, 0, 0);\n\t\t}\n\t\tif (strokeColor) {\n\t\t\tctx.strokeStyle = strokeColor.getCanvasStyle(ctx);\n\t\t\tctx.strokeText(this._content, 0, 0);\n\t\t}\n\t\tctx.restore();\n\t}\n});\n\nvar Style = Item.extend({\n\tinitialize: function(style) {\n\t\tvar clone = style instanceof Style;\n\t\treturn Base.each(this._defaults, function(value, key) {\n\t\t\tvalue = style && style[key] || value;\n\t\t\tthis[key] = value && clone && value.clone\n\t\t\t\t\t? value.clone() : value;\n\t\t}, this);\n\t},\n\n\tstatics: {\n\t\tcreate: function(item) {\n\t\t\tvar style = new this(this.dont);\n\t\t\tstyle._item = item;\n\t\t\treturn style;\n\t\t},\n\n\t\textend: function(src) {\n\t\t\tvar styleKey = src._style,\n\t\t\t\tflags = src._flags || {};\n\t\t\tsrc._owner.inject(Base.each(src._defaults, function(value, key) {\n\t\t\t\tvar isColor = !!key.match(/Color$/),\n\t\t\t\t\tpart = Base.capitalize(key),\n\t\t\t\t\tset = 'set' + part,\n\t\t\t\t\tget = 'get' + part;\n\t\t\t\tsrc[set] = function(value) {\n\t\t\t\t\tvar children = this._item && this._item._children;\n\t\t\t\t\tvalue = isColor ? Color.read(arguments) : value;\n\t\t\t\t\tif (children) {\n\t\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\t\t\tchildren[i][styleKey][set](value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar old = this['_' + key];\n\t\t\t\t\t\tif (old != value && !(old && old.equals\n\t\t\t\t\t\t\t\t\t&& old.equals(value))) {\n\t\t\t\t\t\t\tthis['_' + key] = value;\n\t\t\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\t\t\tif (old)\n\t\t\t\t\t\t\t\t\told._removeOwner(this._item);\n\t\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\t\tvalue._addOwner(this._item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (this._item)\n\t\t\t\t\t\t\t\tthis._item._changed(flags[key] || Change.STYLE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tsrc[get] = function() {\n\t\t\t\t\tvar children = this._item && this._item._children,\n\t\t\t\t\t\tstyle;\n\t\t\t\t\tif (!children)\n\t\t\t\t\t\treturn this['_' + key];\n\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\t\tvar childStyle = children[i][styleKey][get]();\n\t\t\t\t\t\tif (!style) {\n\t\t\t\t\t\t\tstyle = childStyle;\n\t\t\t\t\t\t} else if (style != childStyle && !(style\n\t\t\t\t\t\t\t\t&& style.equals && style.equals(childStyle))) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn style;\n\t\t\t\t};\n\t\t\t\tthis[set] = function(value) {\n\t\t\t\t\tthis[styleKey][set](value);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tthis[get] = function() {\n\t\t\t\t\treturn this[styleKey][get]();\n\t\t\t\t};\n\t\t\t}, {}));\n\t\t\treturn this.base(src);\n\t\t}\n\t}\n});\n\nvar PathStyle = this.PathStyle = Style.extend({\n\t_defaults: {\n\t\tfillColor: undefined,\n\t\tstrokeColor: undefined,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: []\n\t},\n\t_flags: {\n\t\tstrokeWidth: Change.STROKE,\n\t\tstrokeCap: Change.STROKE,\n\t\tstrokeJoin: Change.STROKE,\n\t\tmiterLimit: Change.STROKE\n\t},\n\t_owner: Item,\n\t_style: '_style'\n\n});\n\nvar ParagraphStyle = this.ParagraphStyle = Style.extend({\n\t_defaults: {\n\t\tjustification: 'left'\n\t},\n\t_owner: TextItem,\n\t_style: '_paragraphStyle'\n\n});\n\nvar CharacterStyle = this.CharacterStyle = PathStyle.extend({\n\t_defaults: Base.merge(PathStyle.prototype._defaults, {\n\t\tfillColor: 'black',\n\t\tfontSize: 10,\n\t\tfont: 'sans-serif'\n\t}),\n\t_owner: TextItem,\n\t_style: '_characterStyle'\n\n});\n\nvar Color = this.Color = Base.extend(new function() {\n\n\tvar components = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness']\n\t};\n\n\tvar colorCache = {},\n\t\tcolorContext;\n\n\tfunction nameToRgbColor(name) {\n\t\tvar color = colorCache[name];\n\t\tif (color)\n\t\t\treturn color.clone();\n\t\tif (!colorContext) {\n\t\t\tvar canvas = CanvasProvider.getCanvas(Size.create(1, 1));\n\t\t\tcolorContext = canvas.getContext('2d');\n\t\t\tcolorContext.globalCompositeOperation = 'copy';\n\t\t}\n\t\tcolorContext.fillStyle = 'rgba(0,0,0,0)';\n\t\tcolorContext.fillStyle = name;\n\t\tcolorContext.fillRect(0, 0, 1, 1);\n\t\tvar data = colorContext.getImageData(0, 0, 1, 1).data,\n\t\t\trgb = [data[0] / 255, data[1] / 255, data[2] / 255];\n\t\treturn (colorCache[name] = RgbColor.read(rgb)).clone();\n\t}\n\n\tfunction hexToRgbColor(string) {\n\t\tvar hex = string.match(/^#?(\\w{1,2})(\\w{1,2})(\\w{1,2})$/);\n\t\tif (hex.length >= 4) {\n\t\t\tvar rgb = new Array(3);\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar channel = hex[i + 1];\n\t\t\t\trgb[i] = parseInt(channel.length == 1\n\t\t\t\t\t\t? channel + channel : channel, 16) / 255;\n\t\t\t}\n\t\t\treturn RgbColor.read(rgb);\n\t\t}\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1], \n\t\t[2, 0, 1], \n\t\t[1, 0, 3], \n\t\t[1, 2, 0], \n\t\t[3, 1, 0], \n\t\t[0, 1, 2]  \n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(color) {\n\t\t\tvar r = color._red,\n\t\t\t\tg = color._green,\n\t\t\t\tb = color._blue,\n\t\t\t\tmax = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta == 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60, \n\t\t\t\ts = max == 0 ? 0 : delta / max,\n\t\t\t\tv = max; \n\t\t\treturn new HsbColor(h, s, v, color._alpha);\n\t\t},\n\n\t\t'hsb-rgb': function(color) {\n\t\t\tvar h = (color._hue / 60) % 6, \n\t\t\t\ts = color._saturation,\n\t\t\t\tb = color._brightness,\n\t\t\t\ti = Math.floor(h), \n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\t\t\t\t\t\t\n\t\t\t\t\tb * (1 - s),\t\t\t\n\t\t\t\t\tb * (1 - s * f),\t\t\n\t\t\t\t\tb * (1 - s * (1 - f))\t\n\t\t\t\t];\n\t\t\treturn new RgbColor(v[i[0]], v[i[1]], v[i[2]], color._alpha);\n\t\t},\n\n\t\t'rgb-hsl': function(color) {\n\t\t\tvar r = color._red,\n\t\t\t\tg = color._green,\n\t\t\t\tb = color._blue,\n\t\t\t\tmax = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta == 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60, \n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn new HslColor(h, s, l, color._alpha);\n\t\t},\n\n\t\t'hsl-rgb': function(color) {\n\t\t\tvar s = color._saturation,\n\t\t\t\th = color._hue / 360,\n\t\t\t\tl = color._lightness,\n\t\t\t\tt1, t2, c;\n\t\t\tif (s == 0)\n\t\t\t\treturn new RgbColor(l, l, l, color._alpha);\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn new RgbColor(c[0], c[1], c[2], color._alpha);\n\t\t},\n\n\t\t'rgb-gray': function(color) {\n\t\t\treturn new GrayColor(1 - (color._red * 0.2989 + color._green * 0.587\n\t\t\t\t\t+ color._blue * 0.114), color._alpha);\n\t\t},\n\n\t\t'gray-rgb': function(color) {\n\t\t\tvar comp = 1 - color._gray;\n\t\t\treturn new RgbColor(comp, comp, comp, color._alpha);\n\t\t},\n\n\t\t'gray-hsb': function(color) {\n\t\t\treturn new HsbColor(0, 0, 1 - color._gray, color._alpha);\n\t\t},\n\n\t\t'gray-hsl': function(color) {\n\t\t\treturn new HslColor(0, 0, 1 - color._gray, color._alpha);\n\t\t}\n\t};\n\n\tvar fields = {\n\t\t_readNull: true,\n\n\t\tinitialize: function(arg) {\n\t\t\tvar isArray = Array.isArray(arg),\n\t\t\t\ttype = this._colorType;\n\t\t\tif (typeof arg === 'object' && !isArray) {\n\t\t\t\tif (!type) {\n\t\t\t\t\treturn arg.red !== undefined\n\t\t\t\t\t\t? new RgbColor(arg.red, arg.green, arg.blue, arg.alpha)\n\t\t\t\t\t\t: arg.gray !== undefined\n\t\t\t\t\t\t? new GrayColor(arg.gray, arg.alpha)\n\t\t\t\t\t\t: arg.lightness !== undefined\n\t\t\t\t\t\t? new HslColor(arg.hue, arg.saturation, arg.lightness,\n\t\t\t\t\t\t\t\targ.alpha)\n\t\t\t\t\t\t: arg.hue !== undefined\n\t\t\t\t\t\t? new HsbColor(arg.hue, arg.saturation, arg.brightness,\n\t\t\t\t\t\t\t\targ.alpha)\n\t\t\t\t\t\t: new RgbColor(); \n\t\t\t\t} else {\n\t\t\t\t\treturn Color.read(arguments).convert(type);\n\t\t\t\t}\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tvar rgbColor = arg.match(/^#[0-9a-f]{3,6}$/i)\n\t\t\t\t\t\t? hexToRgbColor(arg)\n\t\t\t\t\t\t: nameToRgbColor(arg);\n\t\t\t\treturn type\n\t\t\t\t\t\t? rgbColor.convert(type)\n\t\t\t\t\t\t: rgbColor;\n\t\t\t} else {\n\t\t\t\tvar components = isArray ? arg\n\t\t\t\t\t\t: Array.prototype.slice.call(arguments);\n\t\t\t\tif (!type) {\n\t\t\t\t\tif (components.length >= 3)\n\t\t\t\t\t\treturn new RgbColor(components);\n\t\t\t\t\treturn new GrayColor(components);\n\t\t\t\t} else {\n\t\t\t\t\tBase.each(this._components,\n\t\t\t\t\t\tfunction(name, i) {\n\t\t\t\t\t\t\tvar value = components[i];\n\t\t\t\t\t\t\tthis['_' + name] = value !== undefined\n\t\t\t\t\t\t\t\t\t? value : null;\n\t\t\t\t\t\t},\n\t\t\t\t\tthis);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tclone: function() {\n\t\t\tvar ctor = this.constructor,\n\t\t\t\tcopy = new ctor(ctor.dont),\n\t\t\t\tcomponents = this._components;\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar key = '_' + components[i];\n\t\t\t\tcopy[key] = this[key];\n\t\t\t}\n\t\t\treturn copy;\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._colorType == type\n\t\t\t\t\t? this.clone()\n\t\t\t\t\t: (converter = converters[this._colorType + '-' + type])\n\t\t\t\t\t\t? converter(this)\n\t\t\t\t\t\t: converters['rgb-' + type](\n\t\t\t\t\t\t\t\tconverters[this._colorType + '-rgb'](this));\n\t\t},\n\n\t\tstatics: {\n\t\t\textend: function(src) {\n\t\t\t\tsrc.beans = true;\n\t\t\t\tif (src._colorType) {\n\t\t\t\t\tvar comps = components[src._colorType];\n\t\t\t\t\tsrc._components = comps.concat(['alpha']);\n\t\t\t\t\tBase.each(comps, function(name) {\n\t\t\t\t\t\tvar isHue = name === 'hue',\n\t\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\t\tname = '_' + name;\n\t\t\t\t\t\tthis['get' + part] = function() {\n\t\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis['set' + part] = function(value) {\n\t\t\t\t\t\t\tthis[name] = isHue\n\t\t\t\t\t\t\t\t? ((value % 360) + 360) % 360\n\t\t\t\t\t\t\t\t: Math.min(Math.max(value, 0), 1);\n\t\t\t\t\t\t\tthis._changed();\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t};\n\t\t\t\t\t}, src);\n\t\t\t\t}\n\t\t\t\treturn this.base(src);\n\t\t\t}\n\t\t}\n\t};\n\n\tBase.each(components, function(comps, type) {\n\t\tBase.each(comps, function(component) {\n\t\t\tvar part = Base.capitalize(component);\n\t\t\tfields['get' + part] = function() {\n\t\t\t\treturn this.convert(type)[component];\n\t\t\t};\n\t\t\tfields['set' + part] = function(value) {\n\t\t\t\tvar color = this.convert(type);\n\t\t\t\tcolor[component] = value;\n\t\t\t\tcolor = color.convert(this._colorType);\n\t\t\t\tfor (var i = 0, l = this._components.length; i < l; i++) {\n\t\t\t\t\tvar key = this._components[i];\n\t\t\t\t\tthis[key] = color[key];\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t});\n\n\treturn fields;\n}, {\n\n\t_changed: function() {\n\t\tthis._cssString = null;\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++)\n\t\t\tthis._owners[i]._changed(Change.STYLE);\n\t},\n\n\t_addOwner: function(item) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(item);\n\t},\n\n\t_removeOwner: function(item) {\n\t\tvar index = this._owners ? this._owners.indexOf(item) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (this._owners.length == 0)\n\t\t\t\tdelete this._owners;\n\t\t}\n\t},\n\n\tgetType: function() {\n\t\treturn this._colorType;\n\t},\n\n\tgetComponents: function() {\n\t\tvar length = this._components.length;\n\t\tvar comps = new Array(length);\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tcomps[i] = this['_' + this._components[i]];\n\t\treturn comps;\n\t},\n\n\tgetAlpha: function() {\n\t\treturn this._alpha != null ? this._alpha : 1;\n\t},\n\n\tsetAlpha: function(alpha) {\n\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\thasAlpha: function() {\n\t\treturn this._alpha != null;\n\t},\n\n\tequals: function(color) {\n\t\tif (color && color._colorType === this._colorType) {\n\t\t\tfor (var i = 0, l = this._components.length; i < l; i++) {\n\t\t\t\tvar component = '_' + this._components[i];\n\t\t\t\tif (this[component] !== color[component])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tformat = Base.formatNumber;\n\t\tfor (var i = 0, l = this._components.length; i < l; i++) {\n\t\t\tvar component = this._components[i],\n\t\t\t\tvalue = this['_' + component];\n\t\t\tif (component === 'alpha' && value == null)\n\t\t\t\tvalue = 1;\n\t\t\tparts.push(component + ': ' + format(value));\n\t\t}\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttoCssString: function() {\n\t\tif (!this._cssString) {\n\t\t\tvar color = this.convert('rgb'),\n\t\t\t\talpha = color.getAlpha(),\n\t\t\t\tcomponents = [\n\t\t\t\t\tMath.round(color._red * 255),\n\t\t\t\t\tMath.round(color._green * 255),\n\t\t\t\t\tMath.round(color._blue * 255),\n\t\t\t\t\talpha != null ? alpha : 1\n\t\t\t\t];\n\t\t\tthis._cssString = 'rgba(' + components.join(', ') + ')';\n\t\t}\n\t\treturn this._cssString;\n\t},\n\n\tgetCanvasStyle: function() {\n\t\treturn this.toCssString();\n\t}\n\n});\n\nvar GrayColor = this.GrayColor = Color.extend({\n\n\t_colorType: 'gray'\n});\n\nvar RgbColor = this.RgbColor = this.RGBColor = Color.extend({\n\n\t_colorType: 'rgb'\n});\n\nvar HsbColor = this.HsbColor = this.HSBColor = Color.extend({\n\n\t_colorType: 'hsb'\n});\n\nvar HslColor = this.HslColor = this.HSLColor = Color.extend({\n\n\t_colorType: 'hsl'\n});\n\nvar GradientColor = this.GradientColor = Color.extend({\n\n\tinitialize: function(gradient, origin, destination, hilite) {\n\t\tthis.gradient = gradient || new Gradient();\n\t\tthis.setOrigin(origin);\n\t\tthis.setDestination(destination);\n\t\tif (hilite)\n\t\t\tthis.setHilite(hilite);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientColor(this.gradient, this._origin, this._destination,\n\t\t\t\tthis._hilite);\n\t},\n\n\tgetOrigin: function() {\n\t\treturn this._origin;\n\t},\n\n\tsetOrigin: function(origin) {\n\t\torigin = Point.read(arguments).clone();\n\t\tthis._origin = origin;\n\t\tif (this._destination)\n\t\t\tthis._radius = this._destination.getDistance(this._origin);\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tgetDestination: function() {\n\t\treturn this._destination;\n\t},\n\n\tsetDestination: function(destination) {\n\t\tdestination = Point.read(arguments).clone();\n\t\tthis._destination = destination;\n\t\tthis._radius = this._destination.getDistance(this._origin);\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tgetHilite: function() {\n\t\treturn this._hilite;\n\t},\n\n\tsetHilite: function(hilite) {\n\t\thilite = Point.read(arguments).clone();\n\t\tvar vector = hilite.subtract(this._origin);\n\t\tif (vector.getLength() > this._radius) {\n\t\t\tthis._hilite = this._origin.add(\n\t\t\t\t\tvector.normalize(this._radius - 0.1));\n\t\t} else {\n\t\t\tthis._hilite = hilite;\n\t\t}\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tgetCanvasStyle: function(ctx) {\n\t\tvar gradient;\n\t\tif (this.gradient.type === 'linear') {\n\t\t\tgradient = ctx.createLinearGradient(this._origin.x, this._origin.y,\n\t\t\t\t\tthis._destination.x, this._destination.y);\n\t\t} else {\n\t\t\tvar origin = this._hilite || this._origin;\n\t\t\tgradient = ctx.createRadialGradient(origin.x, origin.y,\n\t\t\t\t\t0, this._origin.x, this._origin.y, this._radius);\n\t\t}\n\t\tfor (var i = 0, l = this.gradient._stops.length; i < l; i++) {\n\t\t\tvar stop = this.gradient._stops[i];\n\t\t\tgradient.addColorStop(stop._rampPoint, stop._color.toCssString());\n\t\t}\n\t\treturn gradient;\n\t},\n\n\tequals: function(color) {\n\t\treturn color == this || color && color._colorType === this._colorType\n\t\t\t\t&& this.gradient.equals(color.gradient)\n\t\t\t\t&& this._origin.equals(color._origin)\n\t\t\t\t&& this._destination.equals(color._destination);\n\t},\n\n\ttransform: function(matrix) {\n\t\tmatrix._transformPoint(this._origin, this._origin, true);\n\t\tmatrix._transformPoint(this._destination, this._destination, true);\n\t\tif (this._hilite)\n\t\t\tmatrix._transformPoint(this._hilite, this._hilite, true);\n\t\tthis._radius = this._destination.getDistance(this._origin);\n\t}\n});\n\nvar Gradient = this.Gradient = Base.extend({\n\tinitialize: function(stops, type) {\n\t\tthis.setStops(stops || ['white', 'black']);\n\t\tthis.type = type || 'linear';\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\n\t\t\tstops[i] = this._stops[i].clone();\n\t\treturn new Gradient(stops, this.type);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2)\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\tthis._stops = GradientStop.readAll(stops);\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tvar stop = this._stops[i];\n\t\t\tif (stop._defaultRamp)\n\t\t\t\tstop.setRampPoint(i / (l - 1));\n\t\t}\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient.type != this.type)\n\t\t\treturn false;\n\t\tif (this._stops.length == gradient._stops.length) {\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\t\tif (!this._stops[i].equals(gradient._stops[i]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = this.GradientStop = Base.extend({\n\tinitialize: function(arg0, arg1) {\n\t\tif (arg1 === undefined && Array.isArray(arg0)) {\n\t\t\tthis.setColor(arg0[0]);\n\t\t\tthis.setRampPoint(arg0[1]);\n\t\t} else if (arg0.color) {\n\t\t\tthis.setColor(arg0.color);\n\t\t\tthis.setRampPoint(arg0.rampPoint);\n\t\t} else {\n\t\t\tthis.setColor(arg0);\n\t\t\tthis.setRampPoint(arg1);\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._rampPoint);\n\t},\n\n\tgetRampPoint: function() {\n\t\treturn this._rampPoint;\n\t},\n\n\tsetRampPoint: function(rampPoint) {\n\t\tthis._defaultRamp = rampPoint == null;\n\t\tthis._rampPoint = rampPoint || 0;\n\t},\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function(color) {\n\t\tthis._color = Color.read(arguments);\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop == this || stop instanceof GradientStop\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._rampPoint == stop._rampPoint;\n\t}\n});\n\nvar DomElement = {\n\tgetBounds: function(el, viewport) {\n\t\tvar rect = el.getBoundingClientRect(),\n\t\t\tdoc = el.ownerDocument,\n\t\t\tbody = doc.body,\n\t\t\tdocEl = doc.documentElement,\n\t\t\tx = rect.left - (docEl.clientLeft || body.clientLeft || 0),\n\t\t\ty = rect.top - (docEl.clientTop  || body.clientTop  || 0);\n\t\tif (!viewport) {\n\t\t\tvar win = DomElement.getViewport(doc);\n\t\t\tx += win.pageXOffset || docEl.scrollLeft || body.scrollLeft;\n\t\t\ty += win.pageYOffset || docEl.scrollTop || body.scrollTop;\n\t\t}\n\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t},\n\n\tgetOffset: function(el, viewport) {\n\t\treturn this.getBounds(el, viewport).getPoint();\n\t},\n\n\tgetSize: function(el) {\n\t\treturn this.getBounds(el, true).getSize();\n\t},\n\n\tisInvisible: function(el) {\n\t\treturn this.getSize(el).equals([0, 0]);\n\t},\n\n\tisVisible: function(el) {\n\t\treturn !this.isInvisible(el) && this.getViewportBounds(el).intersects(\n\t\t\t\tthis.getBounds(el, true));\n\t},\n\n\tgetViewport: function(doc) {\n\t\treturn doc.defaultView || doc.parentWindow;\n\t},\n\n\tgetViewportBounds: function(el) {\n\t\tvar doc = el.ownerDocument,\n\t\t\tview = this.getViewport(doc),\n\t\t\tbody = doc.getElementsByTagName(\n\t\t\t\tdoc.compatMode === 'CSS1Compat' ? 'html' : 'body')[0];\n\t\treturn Rectangle.create(0, 0, \n\t\t\tview.innerWidth || body.clientWidth,\n\t\t\tview.innerHeight || body.clientHeight\n\t\t);\n\t},\n\n\tgetComputedStyle: function(el, name) {\n\t\tif (el.currentStyle)\n\t\t\treturn el.currentStyle[Base.camelize(name)];\n\t\tvar style = this.getViewport(el.ownerDocument)\n\t\t\t\t.getComputedStyle(el, null);\n\t\treturn style ? style.getPropertyValue(Base.hyphenate(name)) : null;\n\t}\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tfor (var type in events) {\n\t\t\tvar func = events[type];\n\t\t\tif (el.addEventListener) {\n\t\t\t\tel.addEventListener(type, func, false);\n\t\t\t} else if (el.attachEvent) {\n\t\t\t\tel.attachEvent('on' + type, func.bound = function() {\n\t\t\t\t\tfunc.call(el, window.event);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tfor (var type in events) {\n\t\t\tvar func = events[type];\n\t\t\tif (el.removeEventListener) {\n\t\t\t\tel.removeEventListener(type, func, false);\n\t\t\t} else if (el.detachEvent) {\n\t\t\t\tel.detachEvent('on' + type, func.bound);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn Point.create(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t},\n\n\tpreventDefault: function(event) {\n\t\tif (event.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t} else {\n\t\t\tevent.returnValue = false;\n\t\t}\n\t},\n\n\tstopPropagation: function(event) {\n\t\tif (event.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t} else {\n\t\t\tevent.cancelBubble = true;\n\t\t}\n\t},\n\n\tstop: function(event) {\n\t\tDomEvent.stopPropagation(event);\n\t\tDomEvent.preventDefault(event);\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar part = 'equestAnimationFrame',\n\t\trequest = window['r' + part] || window['webkitR' + part]\n\t\t\t|| window['mozR' + part] || window['oR' + part]\n\t\t\t|| window['msR' + part];\n\tif (request) {\n\t\trequest(function(time) {\n\t\t\tif (time == undefined)\n\t\t\t\trequest = null;\n\t\t});\n\t}\n\n\tvar callbacks = [],\n\t\tfocused = true,\n\t\ttimer;\n\n\tDomEvent.add(window, {\n\t\tfocus: function() {\n\t\t\tfocused = true;\n\t\t},\n\t\tblur: function() {\n\t\t\tfocused = false;\n\t\t}\n\t});\n\n\treturn function(callback, element) {\n\t\tif (request)\n\t\t\treturn request(callback, element);\n\t\tcallbacks.push([callback, element]);\n\t\tif (timer)\n\t\t\treturn;\n\t\ttimer = window.setInterval(function() {\n\t\t\tfor (var i = callbacks.length - 1; i >= 0; i--) {\n\t\t\t\tvar entry = callbacks[i],\n\t\t\t\t\tfunc = entry[0],\n\t\t\t\t\tel = entry[1];\n\t\t\t\tif (!el || (PaperScript.getAttribute(el, 'keepalive') == 'true'\n\t\t\t\t\t\t|| focused) && DomElement.isVisible(el)) {\n\t\t\t\t\tcallbacks.splice(i, 1);\n\t\t\t\t\tfunc(Date.now());\n\t\t\t\t}\n\t\t\t}\n\t\t}, 1000 / 60);\n\t};\n};\n\nvar View = this.View = PaperScopeItem.extend({\n\t_list: 'views',\n\t_reference: 'view',\n\n\tinitialize: function(canvas) {\n\t\tthis.base();\n\t\tvar size;\n\n\t\tif (typeof canvas === 'string')\n\t\t\tcanvas = document.getElementById(canvas);\n\t\tif (canvas instanceof HTMLCanvasElement) {\n\t\t\tthis._canvas = canvas;\n\t\t\tif (PaperScript.hasAttribute(canvas, 'resize')) {\n\t\t\t\tvar offset = DomElement.getOffset(canvas, true),\n\t\t\t\t\tthat = this;\n\t\t\t\tsize = DomElement.getViewportBounds(canvas)\n\t\t\t\t\t\t.getSize().subtract(offset);\n\t\t\t\tcanvas.width = size.width;\n\t\t\t\tcanvas.height = size.height;\n\t\t\t\tDomEvent.add(window, {\n\t\t\t\t\tresize: function(event) {\n\t\t\t\t\t\tif (!DomElement.isInvisible(canvas))\n\t\t\t\t\t\t\toffset = DomElement.getOffset(canvas, true);\n\t\t\t\t\t\tthat.setViewSize(DomElement.getViewportBounds(canvas)\n\t\t\t\t\t\t\t\t.getSize().subtract(offset));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsize = DomElement.isInvisible(canvas)\n\t\t\t\t\t? Size.create(parseInt(canvas.getAttribute('width')),\n\t\t\t\t\t\t\tparseInt(canvas.getAttribute('height')))\n\t\t\t\t\t: DomElement.getSize(canvas);\n\t\t\t}\n\t\t\tif (PaperScript.hasAttribute(canvas, 'stats')) {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar element = this._stats.domElement,\n\t\t\t\t\tstyle = element.style,\n\t\t\t\t\toffset = DomElement.getOffset(canvas);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(element);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tsize = new Size(1024, 768);\n\t\t\tthis._canvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tthis._id = this._canvas.getAttribute('id');\n\t\tif (this._id == null)\n\t\t\tthis._canvas.setAttribute('id', this._id = 'canvas-' + View._id++);\n\n\t\tView._views[this._id] = this;\n\t\tthis._viewSize = LinkedSize.create(this, 'setViewSize',\n\t\t\t\tsize.width, size.height);\n\t\tthis._context = this._canvas.getContext('2d');\n\t\tthis._matrix = new Matrix();\n\t\tthis._zoom = 1;\n\n\t\tthis._events = this._createEvents();\n\t\tDomEvent.add(this._canvas, this._events);\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\n\t\tthis._scope._redrawNotified = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this.base())\n\t\t\treturn false;\n\t\tif (View._focused == this)\n\t\t\tView._focused = null;\n\t\tdelete View._views[this._id];\n\t\tDomEvent.remove(this._canvas, this._events);\n\t\tthis._canvas = this._events = this._onFrame = null;\n\t\treturn true;\n\t},\n\n\t_redraw: function() {\n\t\tthis._redrawNeeded = true;\n\t\tif (this._onFrameCallback) {\n\t\t\tthis._onFrameCallback(0, true);\n\t\t} else {\n\t\t\tthis.draw();\n\t\t}\n\t},\n\n\t_transform: function(matrix, flags) {\n\t\tthis._matrix.preConcatenate(matrix);\n\t\tthis._bounds = null;\n\t\tthis._inverse = null;\n\t\tthis._redraw();\n\t},\n\n\tgetCanvas: function() {\n\t\treturn this._canvas;\n\t},\n\n\tgetViewSize: function() {\n\t\treturn this._viewSize;\n\t},\n\n\tsetViewSize: function(size) {\n\t\tsize = Size.read(arguments);\n\t\tvar delta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._canvas.width = size.width;\n\t\tthis._canvas.height = size.height;\n\t\tthis._viewSize.set(size.width, size.height, true);\n\t\tthis._bounds = null;\n\t\tthis._redrawNeeded = true;\n\t\tif (this.onResize) {\n\t\t\tthis.onResize({\n\t\t\t\tsize: size,\n\t\t\t\tdelta: delta\n\t\t\t});\n\t\t}\n\t\tthis._redraw();\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._getInverse()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function(center) {\n\t\tthis.scrollBy(Point.read(arguments).subtract(this.getCenter()));\n\t},\n\n\tgetZoom: function() {\n\t\treturn this._zoom;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis._transform(new Matrix().scale(zoom / this._zoom, this.getCenter()));\n\t\tthis._zoom = zoom;\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isVisible(this._canvas);\n\t},\n\n\tscrollBy: function(point) {\n\t\tthis._transform(new Matrix().translate(Point.read(arguments).negate()));\n\t},\n\n\tdraw: function(checkRedraw) {\n\t\tif (checkRedraw && !this._redrawNeeded)\n\t\t\treturn false;\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t\tvar ctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size._width + 1, size._height + 1);\n\n\t\tctx.save();\n\t\tthis._matrix.applyToContext(ctx);\n\t\tthis._scope.project.draw(ctx);\n\t\tctx.restore();\n\t\tif (this._redrawNeeded) {\n\t\t\tthis._redrawNeeded = false;\n\t\t\tthis._scope._redrawNotified = false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tprojectToView: function(point) {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function(point) {\n\t\treturn this._getInverse()._transformPoint(Point.read(arguments));\n\t},\n\n\t_getInverse: function() {\n\t\tif (!this._inverse)\n\t\t\tthis._inverse = this._matrix.createInverse();\n\t\treturn this._inverse;\n\t},\n\n\tgetOnFrame: function() {\n\t\treturn this._onFrame;\n\t},\n\n\tsetOnFrame: function(onFrame) {\n\t\tthis._onFrame = onFrame;\n\t\tif (!onFrame) {\n\t\t\tdelete this._onFrameCallback;\n\t\t\treturn;\n\t\t}\n\t\tvar that = this,\n\t\t\trequested = false,\n\t\t\tbefore,\n\t\t\ttime = 0,\n\t\t\tcount = 0;\n\t\tthis._onFrameCallback = function(param, dontRequest) {\n\t\t\trequested = false;\n\t\t\tif (!that._onFrame)\n\t\t\t\treturn;\n\t\t\tpaper = that._scope;\n\t\t\trequested = true;\n\t\t\tif (!dontRequest) {\n\t\t\t\tDomEvent.requestAnimationFrame(that._onFrameCallback,\n\t\t\t\t\t\tthat._canvas);\n\t\t\t}\n\t\t\tvar now = Date.now() / 1000,\n\t\t\t \tdelta = before ? now - before : 0;\n\t\t\tthat._onFrame(Base.merge({\n\t\t\t\tdelta: delta, \n\t\t\t\ttime: time += delta, \n\t\t\t\tcount: count++\n\t\t\t}));\n\t\t\tbefore = now;\n\t\t\tthat.draw(true);\n\t\t};\n\t\tif (!requested)\n\t\t\tthis._onFrameCallback();\n\t},\n\n\tonResize: null\n}, {\n\tstatics: {\n\t\t_views: {},\n\t\t_id: 0\n\t}\n}, new function() {\n\tvar tool,\n\t\ttimer,\n\t\tcurPoint,\n\t\ttempFocus,\n\t\tdragging = false;\n\n\tfunction viewToProject(view, event) {\n\t\treturn view.viewToProject(DomEvent.getOffset(event, view._canvas));\n\t}\n\n\tfunction updateFocus() {\n\t\tif (!View._focused || !View._focused.isVisible()) {\n\t\t\tPaperScope.each(function(scope) {\n\t\t\t\tfor (var i = 0, l = scope.views.length; i < l; i++) {\n\t\t\t\t\tvar view = scope.views[i];\n\t\t\t\t\tif (view.isVisible()) {\n\t\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\t\tthrow Base.stop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction mousemove(event) {\n\t\tvar view;\n\t\tif (!dragging) {\n\t\t \tview = View._views[DomEvent.getTarget(event).getAttribute('id')];\n\t\t\tif (view) {\n\t\t\t\tView._focused = tempFocus = view;\n\t\t\t} else if (tempFocus && tempFocus == View._focused) {\n\t\t\t\tView._focused = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (!(view = view || View._focused) || !(tool = view._scope.tool))\n\t\t\treturn;\n\t\tvar point = event && viewToProject(view, event);\n\t\tvar onlyMove = !!(!tool.onMouseDrag && tool.onMouseMove);\n\t\tif (dragging && !onlyMove) {\n\t\t\tcurPoint = point || curPoint;\n\t\t\tif (curPoint && tool.onHandleEvent('mousedrag', curPoint, event)) {\n\t\t\t\tview.draw(true);\n\t\t\t\tDomEvent.stop(event);\n\t\t\t}\n\t\t} else if ((!dragging || onlyMove)\n\t\t\t\t&& tool.onHandleEvent('mousemove', point, event)) {\n\t\t\tview.draw(true);\n\t\t\tDomEvent.stop(event);\n\t\t}\n\t}\n\n\tfunction mouseup(event) {\n\t\tvar view = View._focused;\n\t\tif (!view || !dragging)\n\t\t\treturn;\n\t\tdragging = false;\n\t\tcurPoint = null;\n\t\tif (tool) {\n\t\t\tif (timer != null)\n\t\t\t\ttimer = clearInterval(timer);\n\t\t\tif (tool.onHandleEvent('mouseup', viewToProject(view, event), event)) {\n\t\t\t\tview.draw(true);\n\t\t\t\tDomEvent.stop(event);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction selectstart(event) {\n\t\tif (dragging)\n\t\t\tDomEvent.stop(event);\n\t}\n\n\tDomEvent.add(document, {\n\t\tmousemove: mousemove,\n\t\tmouseup: mouseup,\n\t\ttouchmove: mousemove,\n\t\ttouchend: mouseup,\n\t\tselectstart: selectstart,\n\t\tscroll: updateFocus\n\t});\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\treturn {\n\t\t_createEvents: function() {\n\t\t\tvar view = this;\n\n\t\t\tfunction mousedown(event) {\n\t\t\t\tView._focused = view;\n\t\t\t\tif (!(tool = view._scope.tool))\n\t\t\t\t\treturn;\n\t\t\t\tcurPoint = viewToProject(view, event);\n\t\t\t\tif (tool.onHandleEvent('mousedown', curPoint, event))\n\t\t\t\t\tview.draw(true);\n\t\t\t\tif (tool.eventInterval != null)\n\t\t\t\t\ttimer = setInterval(mousemove, tool.eventInterval);\n\t\t\t\tdragging = true;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tmousedown: mousedown,\n\t\t\t\ttouchstart: mousedown,\n\t\t\t\tselectstart: selectstart\n\t\t\t};\n\t\t},\n\n\t\tstatics: {\n\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar Event = this.Event = Base.extend({\n\tinitialize: function(event) {\n\t\tthis.event = event;\n\t},\n\n\tpreventDefault: function() {\n\t\tDomEvent.preventDefault(this.event);\n\t},\n\n\tstopPropagation: function() {\n\t\tDomEvent.stopPropagation(this.event);\n\t},\n\n\tstop: function() {\n\t\tDomEvent.stop(this.event);\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = this.KeyEvent = Event.extend(new function() {\n\treturn {\n\t\tinitialize: function(down, key, character, event) {\n\t\t\tthis.base(event);\n\t\t\tthis.type = down ? 'keydown' : 'keyup';\n\t\t\tthis.key = key;\n\t\t\tthis.character = character;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\treturn '{ type: ' + this.type\n\t\t\t\t\t+ ', key: ' + this.key\n\t\t\t\t\t+ ', character: ' + this.character\n\t\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t\t+ ' }';\n\t\t}\n\t};\n});\n\nvar Key = this.Key = new function() {\n\n\tvar keys = {\n\t\t 8: 'backspace',\n\t\t13: 'enter',\n\t\t16: 'shift',\n\t\t17: 'control',\n\t\t18: 'option',\n\t\t19: 'pause',\n\t\t20: 'caps-lock',\n\t\t27: 'escape',\n\t\t32: 'space',\n\t\t35: 'end',\n\t\t36: 'home',\n\t\t37: 'left',\n\t\t38: 'up',\n\t\t39: 'right',\n\t\t40: 'down',\n\t\t46: 'delete',\n\t\t91: 'command',\n\t\t93: 'command', \n\t\t224: 'command'  \n\t},\n\n\tmodifiers = Base.merge({\n\t\tshift: false,\n\t\tcontrol: false,\n\t\toption: false,\n\t\tcommand: false,\n\t\tcapsLock: false\n\t}),\n\n\tcharCodeMap = {}, \n\tkeyMap = {}, \n\tdownCode; \n\n\tfunction handleKey(down, keyCode, charCode, event) {\n\t\tvar character = String.fromCharCode(charCode),\n\t\t\tkey = keys[keyCode] || character.toLowerCase(),\n\t\t\thandler = down ? 'onKeyDown' : 'onKeyUp',\n\t\t\tview = View._focused,\n\t\t\tscope = view && view.isVisible() && view._scope,\n\t\t\ttool = scope && scope.tool;\n\t\tkeyMap[key] = down;\n\t\tif (tool && tool[handler]) {\n\t\t\tvar keyEvent = new KeyEvent(down, key, character, event);\n\t\t\tif (tool[handler](keyEvent) === false)\n\t\t\t\tkeyEvent.preventDefault();\n\t\t\tif (view)\n\t\t\t\tview.draw(true);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar code = event.which || event.keyCode;\n\t\t\tvar key = keys[code], name;\n\t\t\tif (key) {\n\t\t\t\tif ((name = Base.camelize(key)) in modifiers)\n\t\t\t\t\tmodifiers[name] = true;\n\t\t\t\tcharCodeMap[code] = 0;\n\t\t\t\thandleKey(true, code, null, event);\n\t\t\t} else {\n\t\t\t\tdownCode = code;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downCode != null) {\n\t\t\t\tvar code = event.which || event.keyCode;\n\t\t\t\tcharCodeMap[downCode] = code;\n\t\t\t\thandleKey(true, downCode, code, event);\n\t\t\t\tdownCode = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar code = event.which || event.keyCode,\n\t\t\t\tkey = keys[code], name;\n\t\t\tif (key && (name = Base.camelize(key)) in modifiers)\n\t\t\t\tmodifiers[name] = false;\n\t\t\tif (charCodeMap[code] != null) {\n\t\t\t\thandleKey(false, code, charCodeMap[code], event);\n\t\t\t\tdelete charCodeMap[code];\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar ToolEvent = this.ToolEvent = Event.extend({\n\tinitialize: function(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this.middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t \t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn /^mouse(down|up)$/.test(this.type)\n\t\t\t\t? this.tool._downCount\n\t\t\t\t: this.tool._count;\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile ((parent instanceof Group && !(parent instanceof Layer))\n\t\t\t\t\t\t|| parent instanceof CompoundPath) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = this.Tool = PaperScopeItem.extend({\n\t_list: 'tools',\n\t_reference: 'tool',\n\n\tinitialize: function() {\n\t\tthis.base();\n\t\tthis._firstMove = true;\n\t\tthis._count = 0;\n\t\tthis._downCount = 0;\n\t},\n\n\teventInterval: null,\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (this._minDistance != null && this._maxDistance != null\n\t\t\t\t&& this._minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = this._minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && this._maxDistance != null\n\t\t\t\t&& this._maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = distance;\n\t\tthis._maxDistance = distance;\n\t},\n\n\tupdateEvent: function(type, pt, minDistance, maxDistance, start,\n\t\t\tneedsChange, matchMaxDistance) {\n\t\tif (!start) {\n\t\t\tif (minDistance != null || maxDistance != null) {\n\t\t\t\tvar minDist = minDistance != null ? minDistance : 0;\n\t\t\t\tvar vector = pt.subtract(this._point);\n\t\t\t\tvar distance = vector.getLength();\n\t\t\t\tif (distance < minDist)\n\t\t\t\t\treturn false;\n\t\t\t\tvar maxDist = maxDistance != null ? maxDistance : 0;\n\t\t\t\tif (maxDist != 0) {\n\t\t\t\t\tif (distance > maxDist) {\n\t\t\t\t\t\tpt = this._point.add(vector.normalize(maxDist));\n\t\t\t\t\t} else if (matchMaxDistance) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needsChange && pt.equals(this._point))\n\t\t\t\treturn false;\n\t\t}\n\t\tthis._lastPoint = start && type == 'mousemove' ? pt : this._point;\n\t\tthis._point = pt;\n\t\tswitch (type) {\n\t\tcase 'mousedown':\n\t\t\tthis._lastPoint = this._downPoint;\n\t\t\tthis._downPoint = this._point;\n\t\t\tthis._downCount++;\n\t\t\tbreak;\n\t\tcase 'mouseup':\n\t\t\tthis._lastPoint = this._downPoint;\n\t\t\tbreak;\n\t\t}\n\t\tthis._count = start ? 0 : this._count + 1;\n\t\treturn true;\n\t},\n\n\tonHandleEvent: function(type, pt, event) {\n\t\tpaper = this._scope;\n\t\tvar called = false;\n\t\tswitch (type) {\n\t\tcase 'mousedown':\n\t\t\tthis.updateEvent(type, pt, null, null, true, false, false);\n\t\t\tif (this.onMouseDown) {\n\t\t\t\tthis.onMouseDown(new ToolEvent(this, type, event));\n\t\t\t\tcalled = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'mousedrag':\n\t\t\tvar needsChange = false,\n\t\t\t\tmatchMaxDistance = false;\n\t\t\twhile (this.updateEvent(type, pt, this.minDistance,\n\t\t\t\t\tthis.maxDistance, false, needsChange, matchMaxDistance)) {\n\t\t\t\tif (this.onMouseDrag) {\n\t\t\t\t\tthis.onMouseDrag(new ToolEvent(this, type, event));\n\t\t\t\t\tcalled = true;\n\t\t\t\t}\n\t\t\t\tneedsChange = true;\n\t\t\t\tmatchMaxDistance = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'mouseup':\n\t\t\tif ((this._point.x != pt.x || this._point.y != pt.y)\n\t\t\t\t\t&& this.updateEvent('mousedrag', pt, this.minDistance,\n\t\t\t\t\t\t\tthis.maxDistance, false, false, false)) {\n\t\t\t\tif (this.onMouseDrag) {\n\t\t\t\t\tthis.onMouseDrag(new ToolEvent(this, type, event));\n\t\t\t\t\tcalled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.updateEvent(type, pt, null, this.maxDistance, false,\n\t\t\t\t\tfalse, false);\n\t\t\tif (this.onMouseUp) {\n\t\t\t\tthis.onMouseUp(new ToolEvent(this, type, event));\n\t\t\t\tcalled = true;\n\t\t\t}\n\t\t\tthis.updateEvent(type, pt, null, null, true, false, false);\n\t\t\tthis._firstMove = true;\n\t\t\tbreak;\n\t\tcase 'mousemove':\n\t\t\twhile (this.updateEvent(type, pt, this.minDistance,\n\t\t\t\t\tthis.maxDistance, this._firstMove, true, false)) {\n\t\t\t\tif (this.onMouseMove) {\n\t\t\t\t\tthis.onMouseMove(new ToolEvent(this, type, event));\n\t\t\t\t\tcalled = true;\n\t\t\t\t}\n\t\t\t\tthis._firstMove = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn called;\n\t}\n});\n\nvar CanvasProvider = {\n\tcanvases: [],\n\tgetCanvas: function(size) {\n\t\tif (this.canvases.length) {\n\t\t\tvar canvas = this.canvases.pop();\n\t\t\tif ((canvas.width != size.width)\n\t\t\t\t\t|| (canvas.height != size.height)) {\n\t\t\t\tcanvas.width = size.width;\n\t\t\t\tcanvas.height = size.height;\n\t\t\t} else {\n\t\t\t\tcanvas.getContext('2d').clearRect(0, 0,\n\t\t\t\t\t\tsize.width + 1, size.height + 1);\n\t\t\t}\n\t\t\treturn canvas;\n\t\t} else {\n\t\t\tvar canvas = document.createElement('canvas');\n\t\t\tcanvas.width = size.width;\n\t\t\tcanvas.height = size.height;\n\t\t\treturn canvas;\n\t\t}\n\t},\n\n\treturnCanvas: function(canvas) {\n\t\tthis.canvases.push(canvas);\n\t}\n};\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tcos = Math.cos,\n\t\tPI = Math.PI;\n\n\treturn {\n\t\tTOLERANCE: 10e-6,\n\t\tEPSILON: 10e-12,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = 0.5 * (b - a),\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0; \n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x);\n\t\t\t\tif (abs(dx) < tolerance)\n\t\t\t\t\treturn x;\n\t\t\t\tvar nx = x - dx;\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? 0.5 * (a + b) : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? 0.5 * (a + b) : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, tolerance) {\n\t\t\tif (abs(a) < tolerance) {\n\t\t\t\tif (abs(b) >= tolerance) {\n\t\t\t\t\troots[0] = -c / b;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (abs(c) < tolerance)\n\t\t\t\t\treturn -1; \n\t\t\t\treturn 0; \n\t\t\t}\n\t\t\tvar q = b * b - 4 * a * c;\n\t\t\tif (q < 0)\n\t\t\t\treturn 0; \n\t\t\tq = sqrt(q);\n\t\t\tif (b < 0)\n\t\t\t\tq = -q;\n\t\t\tq = (b + q) * -0.5;\n\t\t\tvar n = 0;\n\t\t\tif (abs(q) >= tolerance)\n\t\t\t\troots[n++] = c / q;\n\t\t\tif (abs(a) >= tolerance)\n\t\t\t\troots[n++] = q / a;\n\t\t\treturn n; \n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, tolerance) {\n\t\t\tif (abs(a) < tolerance)\n\t\t\t\treturn Numerical.solveQuadratic(b, c, d, roots, tolerance);\n\t\t\tb /= a;\n\t\t\tc /= a;\n\t\t\td /= a;\n\t\t\tvar Q = (b * b - 3 * c) / 9,\n\t\t\t\tR = (2 * b * b * b - 9 * b * c + 27 * d) / 54,\n\t\t\t\tQ3 = Q * Q * Q,\n\t\t\t\tR2 = R * R;\n\t\t\tb /= 3; \n\t\t\tif (R2 < Q3) { \n\t\t\t\tvar theta = Math.acos(R / sqrt(Q3)),\n\t\t\t\t\tq = -2 * sqrt(Q);\n\t\t\t\troots[0] = q * cos(theta / 3) - b;\n\t\t\t\troots[1] = q * cos((theta + 2 * PI) / 3) - b;\n\t\t\t\troots[2] = q * cos((theta - 2 * PI) / 3) - b;\n\t\t\t\treturn 3;\n\t\t\t} else { \n\t\t\t\tvar A = -Math.pow(abs(R) + sqrt(R2 - Q3), 1 / 3);\n\t\t\t\tif (R < 0) A = -A;\n\t\t\t\tvar B = (abs(A) < tolerance) ? 0 : Q / A;\n\t\t\t\troots[0] = (A + B) - b;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t};\n};\n\nvar BlendMode = {\n\tprocess: function(blendMode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tdstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\tdst  = dstData.data,\n\t\t\tsrc  = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max,\n\t\t\tabs = Math.abs,\n\t\t\tsr, sg, sb, sa, \n\t\t\tbr, bg, bb, ba, \n\t\t\tdr, dg, db;     \n\n\t\tfunction getLum(r, g, b) {\n\t\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t\t}\n\n\t\tfunction setLum(r, g, b, l) {\n\t\t\tvar d = l - getLum(r, g, b);\n\t\t\tdr = r + d;\n\t\t\tdg = g + d;\n\t\t\tdb = b + d;\n\t\t\tvar l = getLum(dr, dg, db),\n\t\t\t\tmn = min(dr, dg, db),\n\t\t\t\tmx = max(dr, dg, db);\n\t\t\tif (mn < 0) {\n\t\t\t\tvar lmn = l - mn;\n\t\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\t\tdb = l + (db - l) * l / lmn;\n\t\t\t}\n\t\t\tif (mx > 255) {\n\t\t\t\tvar ln = 255 - l, mxl = mx - l;\n\t\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t\t}\n\t\t}\n\n\t\tfunction getSat(r, g, b) {\n\t\t\treturn max(r, g, b) - min(r, g, b);\n\t\t}\n\n\t\tfunction setSat(r, g, b, s) {\n\t\t\tvar col = [r, g, b],\n\t\t\t\tmx = max(r, g, b), \n\t\t\t\tmn = min(r, g, b), \n\t\t\t\tmd; \n\t\t\tmn = mn == r ? 0 : mn == g ? 1 : 2;\n\t\t\tmx = mx == r ? 0 : mx == g ? 1 : 2;\n\t\t\tmd = min(mn, mx) == 0 ? max(mn, mx) == 1 ? 2 : 1 : 0;\n\t\t\tif (col[mx] > col[mn]) {\n\t\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\t\tcol[mx] = s;\n\t\t\t} else {\n\t\t\t\tcol[md] = col[mx] = 0;\n\t\t\t}\n\t\t\tcol[mn] = 0;\n\t\t\tdr = col[0];\n\t\t\tdg = col[1];\n\t\t\tdb = col[2];\n\t\t}\n\n\t\tvar modes = {\n\t\t\tmultiply: function() {\n\t\t\t\tdr = br * sr / 255;\n\t\t\t\tdg = bg * sg / 255;\n\t\t\t\tdb = bb * sb / 255;\n\t\t\t},\n\n\t\t\tscreen: function() {\n\t\t\t\tdr = 255 - (255 - br) * (255 - sr) / 255;\n\t\t\t\tdg = 255 - (255 - bg) * (255 - sg) / 255;\n\t\t\t\tdb = 255 - (255 - bb) * (255 - sb) / 255;\n\t\t\t},\n\n\t\t\toverlay: function() {\n\t\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t\t},\n\n\t\t\t'soft-light': function() {\n\t\t\t\tvar t = sr * br / 255;\n\t\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\t\tt = sg * bg / 255;\n\t\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\t\tt = sb * bb / 255;\n\t\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t\t},\n\n\t\t\t'hard-light': function() {\n\t\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t\t},\n\n\t\t\t'color-dodge': function() {\n\t\t\t\tdr = sr == 255 ? sr : min(255, br * 255 / (255 - sr));\n\t\t\t\tdg = sg == 255 ? sg : min(255, bg * 255 / (255 - sg));\n\t\t\t\tdb = sb == 255 ? sb : min(255, bb * 255 / (255 - sb));\n\t\t\t},\n\n\t\t\t'color-burn': function() {\n\t\t\t\tdr = sr == 0 ? 0 : max(255 - ((255 - br) * 255) / sr, 0);\n\t\t\t\tdg = sg == 0 ? 0 : max(255 - ((255 - bg) * 255) / sg, 0);\n\t\t\t\tdb = sb == 0 ? 0 : max(255 - ((255 - bb) * 255) / sb, 0);\n\t\t\t},\n\n\t\t\tdarken: function() {\n\t\t\t\tdr = br < sr ? br : sr;\n\t\t\t\tdg = bg < sg ? bg : sg;\n\t\t\t\tdb = bb < sb ? bb : sb;\n\t\t\t},\n\n\t\t\tlighten: function() {\n\t\t\t\tdr = br > sr ? br : sr;\n\t\t\t\tdg = bg > sg ? bg : sg;\n\t\t\t\tdb = bb > sb ? bb : sb;\n\t\t\t},\n\n\t\t\tdifference: function() {\n\t\t\t\tdr = br - sr;\n\t\t\t\tif (dr < 0)\n\t\t\t\t\tdr = -dr;\n\t\t\t\tdg = bg - sg;\n\t\t\t\tif (dg < 0)\n\t\t\t\t\tdg = -dg;\n\t\t\t\tdb = bb - sb;\n\t\t\t\tif (db < 0)\n\t\t\t\t\tdb = -db;\n\t\t\t},\n\n\t\t\texclusion: function() {\n\t\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t\t},\n\n\t\t\thue: function() {\n\t\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t\t},\n\n\t\t\tsaturation: function() {\n\t\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t\t},\n\n\t\t\tluminosity: function() {\n\t\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t\t},\n\n\t\t\tcolor: function() {\n\t\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t\t},\n\n\t\t\tadd: function() {\n\t\t\t\tdr = min(br + sr, 255);\n\t\t\t\tdg = min(bg + sg, 255);\n\t\t\t\tdb = min(bb + sb, 255);\n\t\t\t},\n\n\t\t\tsubtract: function() {\n\t\t\t\tdr = max(br - sr, 0);\n\t\t\t\tdg = max(bg - sg, 0);\n\t\t\t\tdb = max(bb - sb, 0);\n\t\t\t},\n\n\t\t\taverage: function() {\n\t\t\t\tdr = (br + sr) / 2;\n\t\t\t\tdg = (bg + sg) / 2;\n\t\t\t\tdb = (bb + sb) / 2;\n\t\t\t},\n\n\t\t\tnegation: function() {\n\t\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t\t}\n\t\t};\n\n\t\tvar process = modes[blendMode];\n\t\tif (!process)\n\t\t\treturn;\n\n\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\tsr = src[i];\n\t\t\tbr = dst[i];\n\t\t\tsg = src[i + 1];\n\t\t\tbg = dst[i + 1];\n\t\t\tsb = src[i + 2];\n\t\t\tbb = dst[i + 2];\n\t\t\tsa = src[i + 3];\n\t\t\tba = dst[i + 3];\n\t\t\tprocess();\n\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\ta2 = 1 - a1;\n\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t}\n\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t}\n};\n\nvar PaperScript = this.PaperScript = new function() {\nvar parse_js=new function(){function W(a,b,c){var d=[];for(var e=0;e<a.length;++e)d.push(b.call(c,a[e],e));return d}function V(c){return/^[a-z_$][a-z0-9_$]*$/i.test(c)&&c!=\"this\"&&!M(d,c)&&!M(b,c)&&!M(a,c)}function U(a,b){var c={};a===!0&&(a={});for(var d in b)M(b,d)&&(c[d]=a&&M(a,d)?a[d]:b[d]);return c}function T(a,b){return b<1?\"\":Array(b+1).join(a)}function S(a,b){function z(a){var b=a[0],c=r[b];if(!c)throw new Error(\"Can't find generator for \\\"\"+b+'\"');y.push(a);var d=c.apply(b,a.slice(1));y.pop();return d}function x(a){var b=a[0],c=a[1];c!=null&&(b=k([g(b),\"=\",m(c,\"seq\")]));return b}function w(a){return a?a.length==0?\"{}\":\"{\"+e+j(function(){return u(a).join(e)})+e+h(\"}\"):\";\"}function v(a){var b=a.length;return b==0?\"{}\":\"{\"+e+W(a,function(a,d){var f=a[1].length>0,g=j(function(){return h(a[0]?k([\"case\",z(a[0])+\":\"]):\"default:\")},.5)+(f?e+j(function(){return u(a[1]).join(e)}):\"\");!c&&f&&d<b-1&&(g+=\";\");return g}).join(e)+e+h(\"}\")}function u(a,b){for(var d=[],e=a.length-1,f=0;f<=e;++f){var g=a[f],i=z(g);i!=\";\"&&(!c&&f==e&&(g[0]==\"while\"&&O(g[2])||L(g[0],[\"for\",\"for-in\"])&&O(g[4])||g[0]==\"if\"&&O(g[2])&&!g[3]||g[0]==\"if\"&&g[3]&&O(g[3])?i=i.replace(/;*\\s*$/,\";\"):i=i.replace(/;+\\s*$/,\"\")),d.push(i))}return b?d:W(d,h)}function t(a,b,c,d){var e=d||\"function\";a&&(e+=\" \"+g(a)),e+=\"(\"+l(W(b,g))+\")\";return k([e,w(c)])}function s(a){if(a[0]==\"do\")return z([\"block\",[a]]);var b=a;for(;;){var c=b[0];if(c==\"if\"){if(!b[3])return z([\"block\",[a]]);b=b[3]}else if(c==\"while\"||c==\"do\")b=b[2];else if(c==\"for\"||c==\"for-in\")b=b[4];else break}return z(a)}function q(a){var b=a.toString(10),c=[b.replace(/^0\\./,\".\")],d;Math.floor(a)===a?(c.push(\"0x\"+a.toString(16).toLowerCase(),\"0\"+a.toString(8)),(d=/^(.*?)(0+)$/.exec(a))&&c.push(d[1]+\"e\"+d[2].length)):(d=/^0?\\.(0+)(.*)$/.exec(a))&&c.push(d[2]+\"e-\"+(d[1].length+d[2].length),b.substr(b.indexOf(\".\")));return n(c)}function o(a){if(a[0]==\"function\"||a[0]==\"object\"){var b=J(y),c=b.pop(),d=b.pop();while(d){if(d[0]==\"stat\")return!0;if((d[0]==\"seq\"||d[0]==\"call\"||d[0]==\"dot\"||d[0]==\"sub\"||d[0]==\"conditional\")&&d[1]===c||(d[0]==\"binary\"||d[0]==\"assign\"||d[0]==\"unary-postfix\")&&d[2]===c)c=d,d=b.pop();else return!1}}return!M(P,a[0])}function n(a){if(a.length==1)return a[0];if(a.length==2){var b=a[1];a=a[0];return a.length<=b.length?a:b}return n([a[0],n(a.slice(1))])}function m(a){var b=z(a);for(var c=1;c<arguments.length;++c){var d=arguments[c];if(d instanceof Function&&d(a)||a[0]==d)return\"(\"+b+\")\"}return b}function l(a){return a.join(\",\"+f)}function k(a){if(c)return a.join(\" \");var b=[];for(var d=0;d<a.length;++d){var e=a[d+1];b.push(a[d]),e&&(/[a-z0-9_\\x24]$/i.test(a[d].toString())&&/^[a-z0-9_\\x24]/i.test(e.toString())||/[\\+\\-]$/.test(a[d].toString())&&/^[\\+\\-]/.test(e.toString()))&&b.push(\" \")}return b.join(\"\")}function j(a,b){b==null&&(b=1),d+=b;try{return a.apply(null,J(arguments,1))}finally{d-=b}}function h(a){a==null&&(a=\"\"),c&&(a=T(\" \",b.indent_start+d*b.indent_level)+a);return a}function g(a){return a.toString()}b=U(b,{indent_start:0,indent_level:4,quote_keys:!1,space_colon:!1,beautify:!1});var c=!!b.beautify,d=0,e=c?\"\\n\":\"\",f=c?\" \":\"\",r={string:Q,num:q,name:g,toplevel:function(a){return u(a).join(e)},splice:function(a){var b=y[y.length-2][0];return M(R,b)?w.apply(this,arguments):W(u(a,!0),function(a,b){return b>0?h(a):a}).join(e)},block:w,\"var\":function(a){return\"var \"+l(W(a,x))+\";\"},\"const\":function(a){return\"const \"+l(W(a,x))+\";\"},\"try\":function(a,b,c){var d=[\"try\",w(a)];b&&d.push(\"catch\",\"(\"+b[0]+\")\",w(b[1])),c&&d.push(\"finally\",w(c));return k(d)},\"throw\":function(a){return k([\"throw\",z(a)])+\";\"},\"new\":function(a,b){b=b.length>0?\"(\"+l(W(b,z))+\")\":\"\";return k([\"new\",m(a,\"seq\",\"binary\",\"conditional\",\"assign\",function(a){var b=N(),c={};try{b.with_walkers({call:function(){throw c},\"function\":function(){return this}},function(){b.walk(a)})}catch(d){if(d===c)return!0;throw d}})+b])},\"switch\":function(a,b){return k([\"switch\",\"(\"+z(a)+\")\",v(b)])},\"break\":function(a){var b=\"break\";a!=null&&(b+=\" \"+g(a));return b+\";\"},\"continue\":function(a){var b=\"continue\";a!=null&&(b+=\" \"+g(a));return b+\";\"},conditional:function(a,b,c){return k([m(a,\"assign\",\"seq\",\"conditional\"),\"?\",m(b,\"seq\"),\":\",m(c,\"seq\")])},assign:function(a,b,c){a&&a!==!0?a+=\"=\":a=\"=\";return k([z(b),a,m(c,\"seq\")])},dot:function(a){var b=z(a),c=1;a[0]==\"num\"?/\\./.test(a[1])||(b+=\".\"):o(a)&&(b=\"(\"+b+\")\");while(c<arguments.length)b+=\".\"+g(arguments[c++]);return b},call:function(a,b){var c=z(a);o(a)&&(c=\"(\"+c+\")\");return c+\"(\"+l(W(b,function(a){return m(a,\"seq\")}))+\")\"},\"function\":t,defun:t,\"if\":function(a,b,c){var d=[\"if\",\"(\"+z(a)+\")\",c?s(b):z(b)];c&&d.push(\"else\",z(c));return k(d)},\"for\":function(a,b,c,d){var e=[\"for\"];a=(a!=null?z(a):\"\").replace(/;*\\s*$/,\";\"+f),b=(b!=null?z(b):\"\").replace(/;*\\s*$/,\";\"+f),c=(c!=null?z(c):\"\").replace(/;*\\s*$/,\"\");var g=a+b+c;g==\"; ; \"&&(g=\";;\"),e.push(\"(\"+g+\")\",z(d));return k(e)},\"for-in\":function(a,b,c,d){return k([\"for\",\"(\"+(a?z(a).replace(/;+$/,\"\"):z(b)),\"in\",z(c)+\")\",z(d)])},\"while\":function(a,b){return k([\"while\",\"(\"+z(a)+\")\",z(b)])},\"do\":function(a,b){return k([\"do\",z(b),\"while\",\"(\"+z(a)+\")\"])+\";\"},\"return\":function(a){var b=[\"return\"];a!=null&&b.push(z(a));return k(b)+\";\"},binary:function(a,b,c){var d=z(b),e=z(c);if(L(b[0],[\"assign\",\"conditional\",\"seq\"])||b[0]==\"binary\"&&B[a]>B[b[1]])d=\"(\"+d+\")\";if(L(c[0],[\"assign\",\"conditional\",\"seq\"])||c[0]==\"binary\"&&B[a]>=B[c[1]]&&(c[1]!=a||!L(a,[\"&&\",\"||\",\"*\"])))e=\"(\"+e+\")\";return k([d,a,e])},\"unary-prefix\":function(a,b){var c=z(b);b[0]==\"num\"||b[0]==\"unary-prefix\"&&!M(i,a+b[1])||!o(b)||(c=\"(\"+c+\")\");return a+(p(a.charAt(0))?\" \":\"\")+c},\"unary-postfix\":function(a,b){var c=z(b);b[0]==\"num\"||b[0]==\"unary-postfix\"&&!M(i,a+b[1])||!o(b)||(c=\"(\"+c+\")\");return c+a},sub:function(a,b){var c=z(a);o(a)&&(c=\"(\"+c+\")\");return c+\"[\"+z(b)+\"]\"},object:function(a){return a.length==0?\"{}\":\"{\"+e+j(function(){return W(a,function(a){if(a.length==3)return h(t(a[0],a[1][2],a[1][3],a[2]));var d=a[0],e=z(a[1]);b.quote_keys?d=Q(d):(typeof d==\"number\"||!c&&+d+\"\"==d)&&parseFloat(d)>=0?d=q(+d):V(d)||(d=Q(d));return h(k(c&&b.space_colon?[d,\":\",e]:[d+\":\",e]))}).join(\",\"+e)})+e+h(\"}\")},regexp:function(a,b){return\"/\"+a+\"/\"+b},array:function(a){return a.length==0?\"[]\":k([\"[\",l(W(a,function(a){return!c&&a[0]==\"atom\"&&a[1]==\"undefined\"?\"\":m(a,\"seq\")})),\"]\"])},stat:function(a){return z(a).replace(/;*\\s*$/,\";\")},seq:function(){return l(W(J(arguments),z))},label:function(a,b){return k([g(a),\":\",z(b)])},\"with\":function(a,b){return k([\"with\",\"(\"+z(a)+\")\",z(b)])},atom:function(a){return g(a)}},y=[];return z(a)}function Q(a){var b=0,c=0;a=a.replace(/[\\\\\\b\\f\\n\\r\\t\\x22\\x27]/g,function(a){switch(a){case\"\\\\\":return\"\\\\\\\\\";case\"\\b\":return\"\\\\b\";case\"\\f\":return\"\\\\f\";case\"\\n\":return\"\\\\n\";case\"\\r\":return\"\\\\r\";case\"\\t\":return\"\\\\t\";case'\"':++b;return'\"';case\"'\":++c;return\"'\"}return a});return b>c?\"'\"+a.replace(/\\x27/g,\"\\\\'\")+\"'\":'\"'+a.replace(/\\x22/g,'\\\\\"')+'\"'}function O(a){return!a||a[0]==\"block\"&&(!a[1]||a[1].length==0)}function N(){function g(a,b){var c={},e;for(e in a)M(a,e)&&(c[e]=d[e],d[e]=a[e]);var f=b();for(e in c)M(c,e)&&(c[e]?d[e]=c[e]:delete d[e]);return f}function f(a){if(a==null)return null;try{e.push(a);var b=a[0],f=d[b];if(f){var g=f.apply(a,a.slice(1));if(g!=null)return g}f=c[b];return f.apply(a,a.slice(1))}finally{e.pop()}}function b(a){var b=[this[0]];a!=null&&b.push(W(a,f));return b}function a(a){return[this[0],W(a,function(a){var b=[a[0]];a.length>1&&(b[1]=f(a[1]));return b})]}var c={string:function(a){return[this[0],a]},num:function(a){return[this[0],a]},name:function(a){return[this[0],a]},toplevel:function(a){return[this[0],W(a,f)]},block:b,splice:b,\"var\":a,\"const\":a,\"try\":function(a,b,c){return[this[0],W(a,f),b!=null?[b[0],W(b[1],f)]:null,c!=null?W(c,f):null]},\"throw\":function(a){return[this[0],f(a)]},\"new\":function(a,b){return[this[0],f(a),W(b,f)]},\"switch\":function(a,b){return[this[0],f(a),W(b,function(a){return[a[0]?f(a[0]):null,W(a[1],f)]})]},\"break\":function(a){return[this[0],a]},\"continue\":function(a){return[this[0],a]},conditional:function(a,b,c){return[this[0],f(a),f(b),f(c)]},assign:function(a,b,c){return[this[0],a,f(b),f(c)]},dot:function(a){return[this[0],f(a)].concat(J(arguments,1))},call:function(a,b){return[this[0],f(a),W(b,f)]},\"function\":function(a,b,c){return[this[0],a,b.slice(),W(c,f)]},defun:function(a,b,c){return[this[0],a,b.slice(),W(c,f)]},\"if\":function(a,b,c){return[this[0],f(a),f(b),f(c)]},\"for\":function(a,b,c,d){return[this[0],f(a),f(b),f(c),f(d)]},\"for-in\":function(a,b,c,d){return[this[0],f(a),f(b),f(c),f(d)]},\"while\":function(a,b){return[this[0],f(a),f(b)]},\"do\":function(a,b){return[this[0],f(a),f(b)]},\"return\":function(a){return[this[0],f(a)]},binary:function(a,b,c){return[this[0],a,f(b),f(c)]},\"unary-prefix\":function(a,b){return[this[0],a,f(b)]},\"unary-postfix\":function(a,b){return[this[0],a,f(b)]},sub:function(a,b){return[this[0],f(a),f(b)]},object:function(a){return[this[0],W(a,function(a){return a.length==2?[a[0],f(a[1])]:[a[0],f(a[1]),a[2]]})]},regexp:function(a,b){return[this[0],a,b]},array:function(a){return[this[0],W(a,f)]},stat:function(a){return[this[0],f(a)]},seq:function(){return[this[0]].concat(W(J(arguments),f))},label:function(a,b){return[this[0],a,f(b)]},\"with\":function(a,b){return[this[0],f(a),f(b)]},atom:function(a){return[this[0],a]}},d={},e=[];return{walk:f,with_walkers:g,parent:function(){return e[e.length-2]},stack:function(){return e}}}function M(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function L(a,b){for(var c=b.length;--c>=0;)if(b[c]===a)return!0;return!1}function K(a){return a.split(\"\")}function J(a,b){return Array.prototype.slice.call(a,b||0)}function I(a){var b={};for(var c=0;c<a.length;++c)b[a[c]]=!0;return b}function H(a){a instanceof Function&&(a=a());for(var b=1,c=arguments.length;--c>0;++b)arguments[b]();return a}function G(a){var b=J(arguments,1);return function(){return a.apply(this,b.concat(J(arguments)))}}function F(a,b,c){function bk(a){try{++d.in_loop;return a()}finally{--d.in_loop}}function bi(a){var b=bg(a),c=d.token.value;if(e(\"operator\")&&M(A,c)){if(bh(b)){g();return p(\"assign\",A[c],b,bi(a))}i(\"Invalid assignment\")}return b}function bh(a){if(!b)return!0;switch(a[0]){case\"dot\":case\"sub\":case\"new\":case\"call\":return!0;case\"name\":return a[1]!=\"this\"}}function bg(a){var b=bf(a);if(e(\"operator\",\"?\")){g();var c=bj(!1);m(\":\");return p(\"conditional\",b,c,bj(!1,a))}return b}function bf(a){return be(Y(!0),0,a)}function be(a,b,c){var f=e(\"operator\")?d.token.value:null;f&&f==\"in\"&&c&&(f=null);var h=f!=null?B[f]:null;if(h!=null&&h>b){g();var i=be(Y(!0),h,c);return be(p(\"binary\",f,a,i),b,c)}return a}function bd(a,b,c){(b==\"++\"||b==\"--\")&&!bh(c)&&i(\"Invalid use of \"+b+\" operator\");return p(a,b,c)}function bc(a,b){if(e(\"punc\",\".\")){g();return bc(p(\"dot\",a,bb()),b)}if(e(\"punc\",\"[\")){g();return bc(p(\"sub\",a,H(bj,G(m,\"]\"))),b)}if(b&&e(\"punc\",\"(\")){g();return bc(p(\"call\",a,Z(\")\")),!0)}return b&&e(\"operator\")&&M(z,d.token.value)?H(G(bd,\"unary-postfix\",d.token.value,a),g):a}function bb(){switch(d.token.type){case\"name\":case\"operator\":case\"keyword\":case\"atom\":return H(d.token.value,g);default:k()}}function ba(){switch(d.token.type){case\"num\":case\"string\":return H(d.token.value,g)}return bb()}function _(){var a=!0,c=[];while(!e(\"punc\",\"}\")){a?a=!1:m(\",\");if(!b&&e(\"punc\",\"}\"))break;var f=d.token.type,h=ba();f!=\"name\"||h!=\"get\"&&h!=\"set\"||!!e(\"punc\",\":\")?(m(\":\"),c.push([h,bj(!1)])):c.push([bb(),P(!1),h])}g();return p(\"object\",c)}function $(){return p(\"array\",Z(\"]\",!b,!0))}function Z(a,b,c){var d=!0,f=[];while(!e(\"punc\",a)){d?d=!1:m(\",\");if(b&&e(\"punc\",a))break;e(\"punc\",\",\")&&c?f.push([\"atom\",\"undefined\"]):f.push(bj(!1))}g();return f}function X(){var a=Y(!1),b;e(\"punc\",\"(\")?(g(),b=Z(\")\")):b=[];return bc(p(\"new\",a,b),!0)}function W(){return p(\"const\",U())}function V(a){return p(\"var\",U(a))}function U(a){var b=[];for(;;){e(\"name\")||k();var c=d.token.value;g(),e(\"operator\",\"=\")?(g(),b.push([c,bj(!1,a)])):b.push([c]);if(!e(\"punc\",\",\"))break;g()}return b}function T(){var a=R(),b,c;if(e(\"keyword\",\"catch\")){g(),m(\"(\"),e(\"name\")||i(\"Name expected\");var f=d.token.value;g(),m(\")\"),b=[f,R()]}e(\"keyword\",\"finally\")&&(g(),c=R()),!b&&!c&&i(\"Missing catch/finally blocks\");return p(\"try\",a,b,c)}function R(){m(\"{\");var a=[];while(!e(\"punc\",\"}\"))e(\"eof\")&&k(),a.push(t());g();return a}function Q(){var a=q(),b=t(),c;e(\"keyword\",\"else\")&&(g(),c=t());return p(\"if\",a,b,c)}function O(a){var b=a[0]==\"var\"?p(\"name\",a[1][0]):a;g();var c=bj();m(\")\");return p(\"for-in\",a,b,c,bk(t))}function N(a){m(\";\");var b=e(\"punc\",\";\")?null:bj();m(\";\");var c=e(\"punc\",\")\")?null:bj();m(\")\");return p(\"for\",a,b,c,bk(t))}function K(){m(\"(\");var a=null;if(!e(\"punc\",\";\")){a=e(\"keyword\",\"var\")?(g(),V(!0)):bj(!0,!0);if(e(\"operator\",\"in\"))return O(a)}return N(a)}function I(a){var b;n()||(b=e(\"name\")?d.token.value:null),b!=null?(g(),L(b,d.labels)||i(\"Label \"+b+\" without matching loop or statement\")):d.in_loop==0&&i(a+\" not inside a loop or switch\"),o();return p(a,b)}function F(){return p(\"stat\",H(bj,o))}function w(a){d.labels.push(a);var c=d.token,e=t();b&&!M(C,e[0])&&k(c),d.labels.pop();return p(\"label\",a,e)}function s(a){return c?function(){var b=d.token,c=a.apply(this,arguments);c[0]=r(c[0],b,h());return c}:a}function r(a,b,c){return a instanceof E?a:new E(a,b,c)}function q(){m(\"(\");var a=bj();m(\")\");return a}function p(){return J(arguments)}function o(){e(\"punc\",\";\")?g():n()||k()}function n(){return!b&&(d.token.nlb||e(\"eof\")||e(\"punc\",\"}\"))}function m(a){return l(\"punc\",a)}function l(a,b){if(e(a,b))return g();j(d.token,\"Unexpected token \"+d.token.type+\", expected \"+a)}function k(a){a==null&&(a=d.token),j(a,\"Unexpected token: \"+a.type+\" (\"+a.value+\")\")}function j(a,b){i(b,a.line,a.col)}function i(a,b,c,e){var f=d.input.context();u(a,b!=null?b:f.tokline,c!=null?c:f.tokcol,e!=null?e:f.tokpos)}function h(){return d.prev}function g(){d.prev=d.token,d.peeked?(d.token=d.peeked,d.peeked=null):d.token=d.input();return d.token}function f(){return d.peeked||(d.peeked=d.input())}function e(a,b){return v(d.token,a,b)}var d={input:typeof a==\"string\"?x(a,!0):a,token:null,prev:null,peeked:null,in_function:0,in_loop:0,labels:[]};d.token=g();var t=s(function(){e(\"operator\",\"/\")&&(d.peeked=null,d.token=d.input(!0));switch(d.token.type){case\"num\":case\"string\":case\"regexp\":case\"operator\":case\"atom\":return F();case\"name\":return v(f(),\"punc\",\":\")?w(H(d.token.value,g,g)):F();case\"punc\":switch(d.token.value){case\"{\":return p(\"block\",R());case\"[\":case\"(\":return F();case\";\":g();return p(\"block\");default:k()};case\"keyword\":switch(H(d.token.value,g)){case\"break\":return I(\"break\");case\"continue\":return I(\"continue\");case\"debugger\":o();return p(\"debugger\");case\"do\":return function(a){l(\"keyword\",\"while\");return p(\"do\",H(q,o),a)}(bk(t));case\"for\":return K();case\"function\":return P(!0);case\"if\":return Q();case\"return\":d.in_function==0&&i(\"'return' outside of function\");return p(\"return\",e(\"punc\",\";\")?(g(),null):n()?null:H(bj,o));case\"switch\":return p(\"switch\",q(),S());case\"throw\":return p(\"throw\",H(bj,o));case\"try\":return T();case\"var\":return H(V,o);case\"const\":return H(W,o);case\"while\":return p(\"while\",q(),bk(t));case\"with\":return p(\"with\",q(),t());default:k()}}}),P=s(function(a){var b=e(\"name\")?H(d.token.value,g):null;a&&!b&&k(),m(\"(\");return p(a?\"defun\":\"function\",b,function(a,b){while(!e(\"punc\",\")\"))a?a=!1:m(\",\"),e(\"name\")||k(),b.push(d.token.value),g();g();return b}(!0,[]),function(){++d.in_function;var a=d.in_loop;d.in_loop=0;var b=R();--d.in_function,d.in_loop=a;return b}())}),S=G(bk,function(){m(\"{\");var a=[],b=null;while(!e(\"punc\",\"}\"))e(\"eof\")&&k(),e(\"keyword\",\"case\")?(g(),b=[],a.push([bj(),b]),m(\":\")):e(\"keyword\",\"default\")?(g(),m(\":\"),b=[],a.push([null,b])):(b||k(),b.push(t()));g();return a}),Y=s(function(a){if(e(\"operator\",\"new\")){g();return X()}if(e(\"operator\")&&M(y,d.token.value))return bd(\"unary-prefix\",H(d.token.value,g),Y(a));if(e(\"punc\")){switch(d.token.value){case\"(\":g();return bc(H(bj,G(m,\")\")),a);case\"[\":g();return bc($(),a);case\"{\":g();return bc(_(),a)}k()}if(e(\"keyword\",\"function\")){g();return bc(P(!1),a)}if(M(D,d.token.type)){var b=d.token.type==\"regexp\"?p(\"regexp\",d.token.value[0],d.token.value[1]):p(d.token.type,d.token.value);return bc(H(b,g),a)}k()}),bj=s(function(a,b){arguments.length==0&&(a=!0);var c=bi(b);if(a&&e(\"punc\",\",\")){g();return p(\"seq\",c,bj(!0,b))}return c});return p(\"toplevel\",function(a){while(!e(\"eof\"))a.push(t());return a}([]))}function E(a,b,c){this.name=a,this.start=b,this.end=c}function x(b){function P(a){if(a)return I();y(),v();var b=g();if(!b)return x(\"eof\");if(o(b))return C();if(b=='\"'||b==\"'\")return F();if(M(l,b))return x(\"punc\",h());if(b==\".\")return L();if(b==\"/\")return K();if(M(e,b))return J();if(b==\"\\\\\"||q(b))return N();B(\"Unexpected character '\"+b+\"'\")}function O(a,b){try{return b()}catch(c){if(c===w)B(a);else throw c}}function N(){var b=A(r);return M(a,b)?M(i,b)?x(\"operator\",b):M(d,b)?x(\"atom\",b):x(\"keyword\",b):x(\"name\",b)}function L(){h();return o(g())?C(\".\"):x(\"punc\",\".\")}function K(){h();var a=f.regex_allowed;switch(g()){case\"/\":f.comments_before.push(G()),f.regex_allowed=a;return P();case\"*\":f.comments_before.push(H()),f.regex_allowed=a;return P()}return f.regex_allowed?I():J(\"/\")}function J(a){function b(a){if(!g())return a;var c=a+g();if(M(i,c)){h();return b(c)}return a}return x(\"operator\",b(a||h()))}function I(){return O(\"Unterminated regular expression\",function(){var a=!1,b=\"\",c,d=!1;while(c=h(!0))if(a)b+=\"\\\\\"+c,a=!1;else if(c==\"[\")d=!0,b+=c;else if(c==\"]\"&&d)d=!1,b+=c;else{if(c==\"/\"&&!d)break;c==\"\\\\\"?a=!0:b+=c}var e=A(function(a){return M(m,a)});return x(\"regexp\",[b,e])})}function H(){h();return O(\"Unterminated multiline comment\",function(){var a=t(\"*/\",!0),b=f.text.substring(f.pos,a),c=x(\"comment2\",b,!0);f.pos=a+2,f.line+=b.split(\"\\n\").length-1,f.newline_before=b.indexOf(\"\\n\")>=0;return c})}function G(){h();var a=t(\"\\n\"),b;a==-1?(b=f.text.substr(f.pos),f.pos=f.text.length):(b=f.text.substring(f.pos,a),f.pos=a);return x(\"comment1\",b,!0)}function F(){return O(\"Unterminated string constant\",function(){var a=h(),b=\"\";for(;;){var c=h(!0);if(c==\"\\\\\")c=D();else if(c==a)break;b+=c}return x(\"string\",b)})}function E(a){var b=0;for(;a>0;--a){var c=parseInt(h(!0),16);isNaN(c)&&B(\"Invalid hex-character pattern in string\"),b=b<<4|c}return b}function D(){var a=h(!0);switch(a){case\"n\":return\"\\n\";case\"r\":return\"\\r\";case\"t\":return\"\\t\";case\"b\":return\"\\b\";case\"v\":return\"\u000b\";case\"f\":return\"\\f\";case\"0\":return\"\";case\"x\":return String.fromCharCode(E(2));case\"u\":return String.fromCharCode(E(4));case\"\\n\":return\"\";default:return a}}function C(a){var b=!1,c=!1,d=!1,e=a==\".\",f=A(function(f,g){if(f==\"x\"||f==\"X\")return d?!1:d=!0;if(!d&&(f==\"E\"||f==\"e\"))return b?!1:b=c=!0;if(f==\"-\")return c||g==0&&!a?!0:!1;if(f==\"+\")return c;c=!1;if(f==\".\")return!e&&!d?e=!0:!1;return p(f)});a&&(f=a+f);var g=s(f);if(!isNaN(g))return x(\"num\",g);B(\"Invalid syntax: \"+f)}function B(a){u(a,f.tokline,f.tokcol,f.tokpos)}function A(a){var b=\"\",c=g(),d=0;while(c&&a(c,d++))b+=h(),c=g();return b}function y(){while(M(j,g()))h()}function x(a,b,d){f.regex_allowed=a==\"operator\"&&!M(z,b)||a==\"keyword\"&&M(c,b)||a==\"punc\"&&M(k,b);var e={type:a,value:b,line:f.tokline,col:f.tokcol,pos:f.tokpos,nlb:f.newline_before};d||(e.comments_before=f.comments_before,f.comments_before=[]),f.newline_before=!1;return e}function v(){f.tokline=f.line,f.tokcol=f.col,f.tokpos=f.pos}function t(a,b){var c=f.text.indexOf(a,f.pos);if(b&&c==-1)throw w;return c}function n(){return!f.peek()}function h(a){var b=f.text.charAt(f.pos++);if(a&&!b)throw w;b==\"\\n\"?(f.newline_before=!0,++f.line,f.col=0):++f.col;return b}function g(){return f.text.charAt(f.pos)}var f={text:b.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g,\"\\n\").replace(/^\\uFEFF/,\"\"),pos:0,tokpos:0,line:0,tokline:0,col:0,tokcol:0,newline_before:!1,regex_allowed:!1,comments_before:[]};P.context=function(a){a&&(f=a);return f};return P}function v(a,b,c){return a.type==b&&(c==null||a.value==c)}function u(a,b,c,d){throw new t(a,b,c,d)}function t(a,b,c,d){this.message=a,this.line=b,this.col=c,this.pos=d}function s(a){if(f.test(a))return parseInt(a.substr(2),16);if(g.test(a))return parseInt(a.substr(1),8);if(h.test(a))return parseFloat(a)}function r(a){return q(a)||o(a)}function q(a){return a==\"$\"||a==\"_\"||n(a)}function p(a){return o(a)||n(a)}function o(a){a=a.charCodeAt(0);return a>=48&&a<=57}function n(a){a=a.charCodeAt(0);return a>=65&&a<=90||a>=97&&a<=122}var a=I([\"break\",\"case\",\"catch\",\"const\",\"continue\",\"default\",\"delete\",\"do\",\"else\",\"finally\",\"for\",\"function\",\"if\",\"in\",\"instanceof\",\"new\",\"return\",\"switch\",\"throw\",\"try\",\"typeof\",\"var\",\"void\",\"while\",\"with\"]),b=I([\"abstract\",\"boolean\",\"byte\",\"char\",\"class\",\"debugger\",\"double\",\"enum\",\"export\",\"extends\",\"final\",\"float\",\"goto\",\"implements\",\"import\",\"int\",\"interface\",\"long\",\"native\",\"package\",\"private\",\"protected\",\"public\",\"short\",\"static\",\"super\",\"synchronized\",\"throws\",\"transient\",\"volatile\"]),c=I([\"return\",\"new\",\"delete\",\"throw\",\"else\",\"case\"]),d=I([\"false\",\"null\",\"true\",\"undefined\"]),e=I(K(\"+-*&%=<>!?|~^\")),f=/^0x[0-9a-f]+$/i,g=/^0[0-7]+$/,h=/^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i,i=I([\"in\",\"instanceof\",\"typeof\",\"new\",\"void\",\"delete\",\"++\",\"--\",\"+\",\"-\",\"!\",\"~\",\"&\",\"|\",\"^\",\"*\",\"/\",\"%\",\">>\",\"<<\",\">>>\",\"<\",\">\",\"<=\",\">=\",\"==\",\"===\",\"!=\",\"!==\",\"?\",\"=\",\"+=\",\"-=\",\"/=\",\"*=\",\"%=\",\">>=\",\"<<=\",\">>>=\",\"|=\",\"^=\",\"&=\",\"&&\",\"||\"]),j=I(K(\" \\n\\r\\t\")),k=I(K(\"[{}(,.;:\")),l=I(K(\"[]{}(),;:\")),m=I(K(\"gmsiy\"));t.prototype.toString=function(){return this.message+\" (line: \"+this.line+\", col: \"+this.col+\", pos: \"+this.pos+\")\"};var w={},y=I([\"typeof\",\"void\",\"delete\",\"--\",\"++\",\"!\",\"~\",\"-\",\"+\"]),z=I([\"--\",\"++\"]),A=function(a,b,c){while(c<a.length)b[a[c]]=a[c].substr(0,a[c].length-1),c++;return b}([\"+=\",\"-=\",\"/=\",\"*=\",\"%=\",\">>=\",\"<<=\",\">>>=\",\"|=\",\"^=\",\"&=\"],{\"=\":!0},0),B=function(a,b){for(var c=0,d=1;c<a.length;++c,++d){var e=a[c];for(var f=0;f<e.length;++f)b[e[f]]=d}return b}([[\"||\"],[\"&&\"],[\"|\"],[\"^\"],[\"&\"],[\"==\",\"===\",\"!=\",\"!==\"],[\"<\",\">\",\"<=\",\">=\",\"in\",\"instanceof\"],[\">>\",\"<<\",\">>>\"],[\"+\",\"-\"],[\"*\",\"/\",\"%\"]],{}),C=I([\"for\",\"do\",\"while\",\"switch\"]),D=I([\"atom\",\"num\",\"string\",\"regexp\",\"name\"]);E.prototype.toString=function(){return this.name};var P=I([\"name\",\"array\",\"object\",\"string\",\"dot\",\"sub\",\"call\",\"regexp\"]),R=I([\"if\",\"while\",\"do\",\"for\",\"for-in\",\"with\"]);return{parse:F,gen_code:S,tokenizer:x,ast_walker:N}}\n\n\t// Math Operators\n\n\tvar operators = {\n\t\t'+': 'add',\n\t\t'-': 'subtract',\n\t\t'*': 'multiply',\n\t\t'/': 'divide',\n\t\t'%': 'modulo',\n\t\t'==': 'equals',\n\t\t'!=': 'equals'\n\t};\n\n\tfunction $eval(left, operator, right) {\n\t\tvar handler = operators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator == '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\tdefault:\n\t\t\tthrow new Error('Implement Operator: ' + operator);\n\t\t}\n\t};\n\n\t// Sign Operators\n\n\tvar signOperators = {\n\t\t'-': 'negate'\n\t};\n\n\tfunction $sign(operator, value) {\n\t\tvar handler = signOperators[operator];\n\t\tif (value && value[handler]) {\n\t\t\treturn value[handler]();\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\tdefault:\n\t\t\tthrow new Error('Implement Sign Operator: ' + operator);\n\t\t}\n\t}\n\n\t// AST Helpers\n\n\tfunction isDynamic(exp) {\n\t\tvar type = exp[0];\n\t\treturn type != 'num' && type != 'string';\n\t}\n\n\tfunction handleOperator(operator, left, right) {\n\t\t// Only replace operators with calls to $operator if the left hand side\n\t\t// is potentially an object.\n\t\tif (operators[operator] && isDynamic(left)) {\n\t\t\t// Replace with call to $operator(left, operator, right):\n\t\t\treturn ['call', ['name', '$eval'],\n\t\t\t\t\t[left, ['string', operator], right]];\n\t\t}\n\t}\n\n\t/**\n\t * Compiles PaperScript code into JavaScript code.\n\t *\n\t * @name PaperScript.compile\n\t * @function\n\t * @param {String} code The PaperScript code.\n\t * @return {String} The compiled PaperScript as JavaScript code.\n\t */\n\tfunction compile(code) {\n\t\t// Use parse-js to translate the code into a AST structure which is then\n\t\t// walked and parsed for operators to overload. The resulting AST is\n\t\t// translated back to code and evaluated.\n\t\tvar ast = parse_js.parse(code),\n\t\t\twalker = parse_js.ast_walker(),\n\t\t\twalk = walker.walk;\n\n\t\tast = walker.with_walkers({\n\t\t\t'binary': function(operator, left, right) {\n\t\t\t\t// Handle simple mathematical operators here:\n\t\t\t\treturn handleOperator(operator, left = walk(left),\n\t\t\t\t\t\tright = walk(right))\n\t\t\t\t\t\t// Always return something since we're walking left and\n\t\t\t\t\t\t|| [this[0], operator, left, right];\n\t\t\t},\n\n\t\t\t'assign': function(operator, left, right) {\n\t\t\t\tvar res = handleOperator(operator, left = walk(left),\n\t\t\t\t\t\tright = walk(right));\n\t\t\t\tif (res)\n\t\t\t\t\treturn [this[0], true, left, res];\n\t\t\t\treturn [this[0], operator, left, right];\n\t\t\t},\n\n\t\t\t'unary-prefix': function(operator, exp) {\n\t\t\t\tif (signOperators[operator] && isDynamic(exp)) {\n\t\t\t\t\treturn ['call', ['name', '$sign'],\n\t\t\t\t\t\t\t[['string', operator], walk(exp)]];\n\t\t\t\t}\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn walk(ast);\n\t\t});\n\n\t\treturn parse_js.gen_code(ast, {\n\t\t\tbeautify: true\n\t\t});\n\t}\n\n\tfunction evaluate(code, scope) {\n\t\tpaper = scope;\n\t\tvar view = scope.view,\n\t\t\ttool = /on(?:Key|Mouse)(?:Up|Down|Move|Drag)/.test(code)\n\t\t\t\t\t&& new Tool(),\n\t\t\tres;\n\t\twith (scope) {\n\t\t\t(function() {\n\t\t\t\tvar onEditOptions, onSelect, onDeselect, onReselect, onMouseDown,\n\t\t\t\t\tonMouseUp, onMouseDrag, onMouseMove, onKeyDown, onKeyUp,\n\t\t\t\t\tonFrame, onResize,\n\t\t\t\t\thandlers = [ 'onEditOptions', 'onSelect', 'onDeselect',\n\t\t\t\t\t\t'onReselect', 'onMouseDown', 'onMouseUp', 'onMouseDrag',\n\t\t\t\t\t\t'onMouseMove', 'onKeyDown', 'onKeyUp'];\n\t\t\t\tres = eval(compile(code));\n\t\t\t\tif (tool) {\n\t\t\t\t\tBase.each(handlers, function(key) {\n\t\t\t\t\t\ttool[key] = eval(key);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (view) {\n\t\t\t\t\tview.onResize = onResize;\n\t\t\t\t\tview.setOnFrame(onFrame);\n\t\t\t\t\tview.draw();\n\t\t\t\t}\n\t\t\t}).call(scope);\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction request(url, scope) {\n\t\tvar xhr = new (window.ActiveXObject || XMLHttpRequest)(\n\t\t\t\t'Microsoft.XMLHTTP');\n\t\txhr.open('GET', url, true);\n\t\tif (xhr.overrideMimeType) {\n\t\t\txhr.overrideMimeType('text/plain');\n\t\t}\n\t\txhr.onreadystatechange = function() {\n\t\t\tif (xhr.readyState === 4) {\n\t\t\t\treturn evaluate(xhr.responseText, scope);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n\n\tfunction load() {\n\t\tvar scripts = document.getElementsByTagName('script');\n\t\tfor (var i = 0, l = scripts.length; i < l; i++) {\n\t\t\tvar script = scripts[i];\n\t\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t\t&& !script.getAttribute('data-paper-loaded')) {\n\t\t\t\tvar scope = new PaperScope(script);\n\t\t\t\tscope.setup(PaperScript.getAttribute(script, 'canvas'));\n\t\t\t\tif (script.src) {\n\t\t\t\t\trequest(script.src, scope);\n\t\t\t\t} else {\n\t\t\t\t\tevaluate(script.innerHTML, scope);\n\t\t\t\t}\n\t\t\t\tscript.setAttribute('data-paper-loaded', true);\n\t\t\t}\n\t\t}\n\t}\n\n\tDomEvent.add(window, { load: load });\n\n\tfunction handleAttribute(name) {\n\t\tname += 'Attribute';\n\t\treturn function(el, attr) {\n\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t};\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\tevaluate: evaluate,\n\t\tload: load,\n\t\tgetAttribute: handleAttribute('get'),\n\t\thasAttribute: handleAttribute('has')\n\t};\n\n};\n\nthis.load = PaperScript.load;\n\nBase.each(this, function(val, key) {\n\tif (val && val.prototype instanceof Base) {\n\t\tval._name = key;\n\t}\n});\n\nthis.enumerable = true;\nreturn new (PaperScope.inject(this));\n};"]],"start1":0,"start2":0,"length1":0,"length2":218614}]],"length":218614,"saved":false}
